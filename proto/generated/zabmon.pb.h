// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zabmon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zabmon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zabmon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zabmon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zabmon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zabmon_2eproto;
namespace zabmon {
class CreateGroupRequest;
struct CreateGroupRequestDefaultTypeInternal;
extern CreateGroupRequestDefaultTypeInternal _CreateGroupRequest_default_instance_;
class CreateHostRequest;
struct CreateHostRequestDefaultTypeInternal;
extern CreateHostRequestDefaultTypeInternal _CreateHostRequest_default_instance_;
class CreateItemRequest;
struct CreateItemRequestDefaultTypeInternal;
extern CreateItemRequestDefaultTypeInternal _CreateItemRequest_default_instance_;
class CreateTemplateRequest;
struct CreateTemplateRequestDefaultTypeInternal;
extern CreateTemplateRequestDefaultTypeInternal _CreateTemplateRequest_default_instance_;
class DeleteGroupRequest;
struct DeleteGroupRequestDefaultTypeInternal;
extern DeleteGroupRequestDefaultTypeInternal _DeleteGroupRequest_default_instance_;
class DeleteHostRequest;
struct DeleteHostRequestDefaultTypeInternal;
extern DeleteHostRequestDefaultTypeInternal _DeleteHostRequest_default_instance_;
class DeleteItemRequest;
struct DeleteItemRequestDefaultTypeInternal;
extern DeleteItemRequestDefaultTypeInternal _DeleteItemRequest_default_instance_;
class DeleteTemplateRequest;
struct DeleteTemplateRequestDefaultTypeInternal;
extern DeleteTemplateRequestDefaultTypeInternal _DeleteTemplateRequest_default_instance_;
class Group;
struct GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class Host;
struct HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class Interface;
struct InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemValues;
struct ItemValuesDefaultTypeInternal;
extern ItemValuesDefaultTypeInternal _ItemValues_default_instance_;
class ListGroupsRequest;
struct ListGroupsRequestDefaultTypeInternal;
extern ListGroupsRequestDefaultTypeInternal _ListGroupsRequest_default_instance_;
class ListGroupsResponse;
struct ListGroupsResponseDefaultTypeInternal;
extern ListGroupsResponseDefaultTypeInternal _ListGroupsResponse_default_instance_;
class ListHostsRequest;
struct ListHostsRequestDefaultTypeInternal;
extern ListHostsRequestDefaultTypeInternal _ListHostsRequest_default_instance_;
class ListHostsResponse;
struct ListHostsResponseDefaultTypeInternal;
extern ListHostsResponseDefaultTypeInternal _ListHostsResponse_default_instance_;
class ListItemsRequest;
struct ListItemsRequestDefaultTypeInternal;
extern ListItemsRequestDefaultTypeInternal _ListItemsRequest_default_instance_;
class ListItemsResponse;
struct ListItemsResponseDefaultTypeInternal;
extern ListItemsResponseDefaultTypeInternal _ListItemsResponse_default_instance_;
class ListItemsValuesRequest;
struct ListItemsValuesRequestDefaultTypeInternal;
extern ListItemsValuesRequestDefaultTypeInternal _ListItemsValuesRequest_default_instance_;
class ListItemsValuesResponse;
struct ListItemsValuesResponseDefaultTypeInternal;
extern ListItemsValuesResponseDefaultTypeInternal _ListItemsValuesResponse_default_instance_;
class ListTemplatesRequest;
struct ListTemplatesRequestDefaultTypeInternal;
extern ListTemplatesRequestDefaultTypeInternal _ListTemplatesRequest_default_instance_;
class ListTemplatesResponse;
struct ListTemplatesResponseDefaultTypeInternal;
extern ListTemplatesResponseDefaultTypeInternal _ListTemplatesResponse_default_instance_;
class Template;
struct TemplateDefaultTypeInternal;
extern TemplateDefaultTypeInternal _Template_default_instance_;
class UpdateHostRequest;
struct UpdateHostRequestDefaultTypeInternal;
extern UpdateHostRequestDefaultTypeInternal _UpdateHostRequest_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace zabmon
PROTOBUF_NAMESPACE_OPEN
template<> ::zabmon::CreateGroupRequest* Arena::CreateMaybeMessage<::zabmon::CreateGroupRequest>(Arena*);
template<> ::zabmon::CreateHostRequest* Arena::CreateMaybeMessage<::zabmon::CreateHostRequest>(Arena*);
template<> ::zabmon::CreateItemRequest* Arena::CreateMaybeMessage<::zabmon::CreateItemRequest>(Arena*);
template<> ::zabmon::CreateTemplateRequest* Arena::CreateMaybeMessage<::zabmon::CreateTemplateRequest>(Arena*);
template<> ::zabmon::DeleteGroupRequest* Arena::CreateMaybeMessage<::zabmon::DeleteGroupRequest>(Arena*);
template<> ::zabmon::DeleteHostRequest* Arena::CreateMaybeMessage<::zabmon::DeleteHostRequest>(Arena*);
template<> ::zabmon::DeleteItemRequest* Arena::CreateMaybeMessage<::zabmon::DeleteItemRequest>(Arena*);
template<> ::zabmon::DeleteTemplateRequest* Arena::CreateMaybeMessage<::zabmon::DeleteTemplateRequest>(Arena*);
template<> ::zabmon::Group* Arena::CreateMaybeMessage<::zabmon::Group>(Arena*);
template<> ::zabmon::Host* Arena::CreateMaybeMessage<::zabmon::Host>(Arena*);
template<> ::zabmon::Interface* Arena::CreateMaybeMessage<::zabmon::Interface>(Arena*);
template<> ::zabmon::Item* Arena::CreateMaybeMessage<::zabmon::Item>(Arena*);
template<> ::zabmon::ItemValues* Arena::CreateMaybeMessage<::zabmon::ItemValues>(Arena*);
template<> ::zabmon::ListGroupsRequest* Arena::CreateMaybeMessage<::zabmon::ListGroupsRequest>(Arena*);
template<> ::zabmon::ListGroupsResponse* Arena::CreateMaybeMessage<::zabmon::ListGroupsResponse>(Arena*);
template<> ::zabmon::ListHostsRequest* Arena::CreateMaybeMessage<::zabmon::ListHostsRequest>(Arena*);
template<> ::zabmon::ListHostsResponse* Arena::CreateMaybeMessage<::zabmon::ListHostsResponse>(Arena*);
template<> ::zabmon::ListItemsRequest* Arena::CreateMaybeMessage<::zabmon::ListItemsRequest>(Arena*);
template<> ::zabmon::ListItemsResponse* Arena::CreateMaybeMessage<::zabmon::ListItemsResponse>(Arena*);
template<> ::zabmon::ListItemsValuesRequest* Arena::CreateMaybeMessage<::zabmon::ListItemsValuesRequest>(Arena*);
template<> ::zabmon::ListItemsValuesResponse* Arena::CreateMaybeMessage<::zabmon::ListItemsValuesResponse>(Arena*);
template<> ::zabmon::ListTemplatesRequest* Arena::CreateMaybeMessage<::zabmon::ListTemplatesRequest>(Arena*);
template<> ::zabmon::ListTemplatesResponse* Arena::CreateMaybeMessage<::zabmon::ListTemplatesResponse>(Arena*);
template<> ::zabmon::Template* Arena::CreateMaybeMessage<::zabmon::Template>(Arena*);
template<> ::zabmon::UpdateHostRequest* Arena::CreateMaybeMessage<::zabmon::UpdateHostRequest>(Arena*);
template<> ::zabmon::Value* Arena::CreateMaybeMessage<::zabmon::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zabmon {

enum ValueType : int {
  VALUE_TYPE_INVALID = 0,
  VALUE_TYPE_NUMERIC_FLOAT = 1,
  VALUE_TYPE_CHARACTER = 2,
  VALUE_TYPE_LOG = 3,
  VALUE_TYPE_NUMERIC_UNSIGNED = 4,
  VALUE_TYPE_TEXT = 5,
  ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ValueType_IsValid(int value);
constexpr ValueType ValueType_MIN = VALUE_TYPE_INVALID;
constexpr ValueType ValueType_MAX = VALUE_TYPE_TEXT;
constexpr int ValueType_ARRAYSIZE = ValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValueType_descriptor();
template<typename T>
inline const std::string& ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValueType_descriptor(), enum_t_value);
}
inline bool ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValueType>(
    ValueType_descriptor(), name, value);
}
enum ItemType : int {
  ITEM_TYPE_INVALID = 0,
  ITEM_TYPE_ZABBIX_AGENT = 1,
  ITEM_TYPE_SNMPV1_AGENT = 2,
  ITEM_TYPE_TRAPPER = 3,
  ITEM_TYPE_SIMPLE_CHECK = 4,
  ITEM_TYPE_SNMPV2_AGENT = 5,
  ITEM_TYPE_INTERNAL = 6,
  ITEM_TYPE_SNMPV3_AGENT = 7,
  ITEM_TYPE_ZABBIX_AGENT_ACTIVE = 8,
  ITEM_TYPE_AGGREGATE = 9,
  ITEM_TYPE_WEB_ELEMENT = 10,
  ITEM_TYPE_EXTERNAL_CHECK = 11,
  ITEM_TYPE_DATABASE_MONITOR = 12,
  ITEM_TYPE_IPMI_AGENT = 13,
  ITEM_TYPE_SSH_AGENT = 14,
  ITEM_TYPE_TELNET_AGENT = 15,
  ITEM_TYPE_CALCULATED = 16,
  ITEM_TYPE_JMX_AGENT = 17,
  ITEM_TYPE_SNMP_TRAP = 18,
  ITEM_TYPE_DEPENDENT_ITEM = 19,
  ITEM_TYPE_HTTP_AGENT = 20,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ITEM_TYPE_INVALID;
constexpr ItemType ItemType_MAX = ITEM_TYPE_HTTP_AGENT;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
// ===================================================================

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricKeyFieldNumber = 2,
    kDelayFieldNumber = 5,
    kIdFieldNumber = 6,
    kInterfaceIdFieldNumber = 7,
    kNameFieldNumber = 8,
    kParentIdFieldNumber = 9,
    kTypeFieldNumber = 3,
    kValueTypeFieldNumber = 4,
  };
  // string metric_key = 2;
  void clear_metric_key();
  const std::string& metric_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metric_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metric_key();
  PROTOBUF_NODISCARD std::string* release_metric_key();
  void set_allocated_metric_key(std::string* metric_key);
  private:
  const std::string& _internal_metric_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_key(const std::string& value);
  std::string* _internal_mutable_metric_key();
  public:

  // string delay = 5;
  void clear_delay();
  const std::string& delay() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delay(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delay();
  PROTOBUF_NODISCARD std::string* release_delay();
  void set_allocated_delay(std::string* delay);
  private:
  const std::string& _internal_delay() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delay(const std::string& value);
  std::string* _internal_mutable_delay();
  public:

  // string id = 6;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string interface_id = 7;
  void clear_interface_id();
  const std::string& interface_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* interface_id);
  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(const std::string& value);
  std::string* _internal_mutable_interface_id();
  public:

  // string name = 8;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent_id = 9;
  void clear_parent_id();
  const std::string& parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // .zabmon.ItemType type = 3;
  void clear_type();
  ::zabmon::ItemType type() const;
  void set_type(::zabmon::ItemType value);
  private:
  ::zabmon::ItemType _internal_type() const;
  void _internal_set_type(::zabmon::ItemType value);
  public:

  // .zabmon.ValueType value_type = 4;
  void clear_value_type();
  ::zabmon::ValueType value_type() const;
  void set_value_type(::zabmon::ValueType value);
  private:
  ::zabmon::ValueType _internal_value_type() const;
  void _internal_set_value_type(::zabmon::ValueType value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delay_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  int type_;
  int value_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ItemValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ItemValues) */ {
 public:
  inline ItemValues() : ItemValues(nullptr) {}
  ~ItemValues() override;
  explicit PROTOBUF_CONSTEXPR ItemValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemValues(const ItemValues& from);
  ItemValues(ItemValues&& from) noexcept
    : ItemValues() {
    *this = ::std::move(from);
  }

  inline ItemValues& operator=(const ItemValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemValues& operator=(ItemValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemValues* internal_default_instance() {
    return reinterpret_cast<const ItemValues*>(
               &_ItemValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemValues& a, ItemValues& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemValues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemValues& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemValues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ItemValues";
  }
  protected:
  explicit ItemValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kItemFieldNumber = 2,
  };
  // repeated .zabmon.Value values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::zabmon::Value* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Value >*
      mutable_values();
  private:
  const ::zabmon::Value& _internal_values(int index) const;
  ::zabmon::Value* _internal_add_values();
  public:
  const ::zabmon::Value& values(int index) const;
  ::zabmon::Value* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Value >&
      values() const;

  // .zabmon.Item item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::zabmon::Item& item() const;
  PROTOBUF_NODISCARD ::zabmon::Item* release_item();
  ::zabmon::Item* mutable_item();
  void set_allocated_item(::zabmon::Item* item);
  private:
  const ::zabmon::Item& _internal_item() const;
  ::zabmon::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::zabmon::Item* item);
  ::zabmon::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:zabmon.ItemValues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Value > values_;
  ::zabmon::Item* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Value& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 6,
    kTimestampFieldNumber = 1,
  };
  // string value = 6;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:zabmon.Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class Group final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.Group) */ {
 public:
  inline Group() : Group(nullptr) {}
  ~Group() override;
  explicit PROTOBUF_CONSTEXPR Group(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Group(const Group& from);
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  inline Group& operator=(Group&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Group& default_instance() {
    return *internal_default_instance();
  }
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }
  inline void Swap(Group* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Group* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Group* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Group& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Group& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.Group";
  }
  protected:
  explicit Group(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemplatesIdsFieldNumber = 3,
    kNameFieldNumber = 1,
    kIdFieldNumber = 4,
  };
  // repeated string templates_ids = 3;
  int templates_ids_size() const;
  private:
  int _internal_templates_ids_size() const;
  public:
  void clear_templates_ids();
  const std::string& templates_ids(int index) const;
  std::string* mutable_templates_ids(int index);
  void set_templates_ids(int index, const std::string& value);
  void set_templates_ids(int index, std::string&& value);
  void set_templates_ids(int index, const char* value);
  void set_templates_ids(int index, const char* value, size_t size);
  std::string* add_templates_ids();
  void add_templates_ids(const std::string& value);
  void add_templates_ids(std::string&& value);
  void add_templates_ids(const char* value);
  void add_templates_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& templates_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_templates_ids();
  private:
  const std::string& _internal_templates_ids(int index) const;
  std::string* _internal_add_templates_ids();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.Group)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> templates_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class Interface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.Interface) */ {
 public:
  inline Interface() : Interface(nullptr) {}
  ~Interface() override;
  explicit PROTOBUF_CONSTEXPR Interface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Interface(const Interface& from);
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interface& operator=(Interface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Interface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }
  inline void Swap(Interface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Interface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Interface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Interface& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.Interface";
  }
  protected:
  explicit Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kDnsFieldNumber = 3,
    kIdFieldNumber = 4,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string dns = 3;
  void clear_dns();
  const std::string& dns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns();
  PROTOBUF_NODISCARD std::string* release_dns();
  void set_allocated_dns(std::string* dns);
  private:
  const std::string& _internal_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns(const std::string& value);
  std::string* _internal_mutable_dns();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.Interface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class Template final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.Template) */ {
 public:
  inline Template() : Template(nullptr) {}
  ~Template() override;
  explicit PROTOBUF_CONSTEXPR Template(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Template(const Template& from);
  Template(Template&& from) noexcept
    : Template() {
    *this = ::std::move(from);
  }

  inline Template& operator=(const Template& from) {
    CopyFrom(from);
    return *this;
  }
  inline Template& operator=(Template&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Template& default_instance() {
    return *internal_default_instance();
  }
  static inline const Template* internal_default_instance() {
    return reinterpret_cast<const Template*>(
               &_Template_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Template& a, Template& b) {
    a.Swap(&b);
  }
  inline void Swap(Template* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Template* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Template* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Template>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Template& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Template& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Template* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.Template";
  }
  protected:
  explicit Template(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsIdsFieldNumber = 3,
    kNameFieldNumber = 1,
    kIdFieldNumber = 4,
  };
  // repeated string groups_ids = 3;
  int groups_ids_size() const;
  private:
  int _internal_groups_ids_size() const;
  public:
  void clear_groups_ids();
  const std::string& groups_ids(int index) const;
  std::string* mutable_groups_ids(int index);
  void set_groups_ids(int index, const std::string& value);
  void set_groups_ids(int index, std::string&& value);
  void set_groups_ids(int index, const char* value);
  void set_groups_ids(int index, const char* value, size_t size);
  std::string* add_groups_ids();
  void add_groups_ids(const std::string& value);
  void add_groups_ids(std::string&& value);
  void add_groups_ids(const char* value);
  void add_groups_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups_ids();
  private:
  const std::string& _internal_groups_ids(int index) const;
  std::string* _internal_add_groups_ids();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.Template)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class Host final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.Host) */ {
 public:
  inline Host() : Host(nullptr) {}
  ~Host() override;
  explicit PROTOBUF_CONSTEXPR Host(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Host(const Host& from);
  Host(Host&& from) noexcept
    : Host() {
    *this = ::std::move(from);
  }

  inline Host& operator=(const Host& from) {
    CopyFrom(from);
    return *this;
  }
  inline Host& operator=(Host&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Host& default_instance() {
    return *internal_default_instance();
  }
  static inline const Host* internal_default_instance() {
    return reinterpret_cast<const Host*>(
               &_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Host& a, Host& b) {
    a.Swap(&b);
  }
  inline void Swap(Host* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Host* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Host* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Host>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Host& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Host& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Host* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.Host";
  }
  protected:
  explicit Host(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfacesFieldNumber = 2,
    kGroupsIdsFieldNumber = 5,
    kTemplatesIdsFieldNumber = 6,
    kNameFieldNumber = 1,
    kIdFieldNumber = 7,
  };
  // repeated .zabmon.Interface interfaces = 2;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;
  public:
  void clear_interfaces();
  ::zabmon::Interface* mutable_interfaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Interface >*
      mutable_interfaces();
  private:
  const ::zabmon::Interface& _internal_interfaces(int index) const;
  ::zabmon::Interface* _internal_add_interfaces();
  public:
  const ::zabmon::Interface& interfaces(int index) const;
  ::zabmon::Interface* add_interfaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Interface >&
      interfaces() const;

  // repeated string groups_ids = 5;
  int groups_ids_size() const;
  private:
  int _internal_groups_ids_size() const;
  public:
  void clear_groups_ids();
  const std::string& groups_ids(int index) const;
  std::string* mutable_groups_ids(int index);
  void set_groups_ids(int index, const std::string& value);
  void set_groups_ids(int index, std::string&& value);
  void set_groups_ids(int index, const char* value);
  void set_groups_ids(int index, const char* value, size_t size);
  std::string* add_groups_ids();
  void add_groups_ids(const std::string& value);
  void add_groups_ids(std::string&& value);
  void add_groups_ids(const char* value);
  void add_groups_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups_ids();
  private:
  const std::string& _internal_groups_ids(int index) const;
  std::string* _internal_add_groups_ids();
  public:

  // repeated string templates_ids = 6;
  int templates_ids_size() const;
  private:
  int _internal_templates_ids_size() const;
  public:
  void clear_templates_ids();
  const std::string& templates_ids(int index) const;
  std::string* mutable_templates_ids(int index);
  void set_templates_ids(int index, const std::string& value);
  void set_templates_ids(int index, std::string&& value);
  void set_templates_ids(int index, const char* value);
  void set_templates_ids(int index, const char* value, size_t size);
  std::string* add_templates_ids();
  void add_templates_ids(const std::string& value);
  void add_templates_ids(std::string&& value);
  void add_templates_ids(const char* value);
  void add_templates_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& templates_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_templates_ids();
  private:
  const std::string& _internal_templates_ids(int index) const;
  std::string* _internal_add_templates_ids();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 7;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.Host)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Interface > interfaces_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> templates_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class CreateHostRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.CreateHostRequest) */ {
 public:
  inline CreateHostRequest() : CreateHostRequest(nullptr) {}
  ~CreateHostRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateHostRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateHostRequest(const CreateHostRequest& from);
  CreateHostRequest(CreateHostRequest&& from) noexcept
    : CreateHostRequest() {
    *this = ::std::move(from);
  }

  inline CreateHostRequest& operator=(const CreateHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateHostRequest& operator=(CreateHostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateHostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateHostRequest* internal_default_instance() {
    return reinterpret_cast<const CreateHostRequest*>(
               &_CreateHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateHostRequest& a, CreateHostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateHostRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateHostRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateHostRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateHostRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateHostRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateHostRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateHostRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.CreateHostRequest";
  }
  protected:
  explicit CreateHostRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
  };
  // .zabmon.Host host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const ::zabmon::Host& host() const;
  PROTOBUF_NODISCARD ::zabmon::Host* release_host();
  ::zabmon::Host* mutable_host();
  void set_allocated_host(::zabmon::Host* host);
  private:
  const ::zabmon::Host& _internal_host() const;
  ::zabmon::Host* _internal_mutable_host();
  public:
  void unsafe_arena_set_allocated_host(
      ::zabmon::Host* host);
  ::zabmon::Host* unsafe_arena_release_host();

  // @@protoc_insertion_point(class_scope:zabmon.CreateHostRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zabmon::Host* host_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class UpdateHostRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.UpdateHostRequest) */ {
 public:
  inline UpdateHostRequest() : UpdateHostRequest(nullptr) {}
  ~UpdateHostRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateHostRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateHostRequest(const UpdateHostRequest& from);
  UpdateHostRequest(UpdateHostRequest&& from) noexcept
    : UpdateHostRequest() {
    *this = ::std::move(from);
  }

  inline UpdateHostRequest& operator=(const UpdateHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateHostRequest& operator=(UpdateHostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateHostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateHostRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateHostRequest*>(
               &_UpdateHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateHostRequest& a, UpdateHostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateHostRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateHostRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateHostRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateHostRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateHostRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateHostRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateHostRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.UpdateHostRequest";
  }
  protected:
  explicit UpdateHostRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
  };
  // .zabmon.Host host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const ::zabmon::Host& host() const;
  PROTOBUF_NODISCARD ::zabmon::Host* release_host();
  ::zabmon::Host* mutable_host();
  void set_allocated_host(::zabmon::Host* host);
  private:
  const ::zabmon::Host& _internal_host() const;
  ::zabmon::Host* _internal_mutable_host();
  public:
  void unsafe_arena_set_allocated_host(
      ::zabmon::Host* host);
  ::zabmon::Host* unsafe_arena_release_host();

  // @@protoc_insertion_point(class_scope:zabmon.UpdateHostRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zabmon::Host* host_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class DeleteHostRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.DeleteHostRequest) */ {
 public:
  inline DeleteHostRequest() : DeleteHostRequest(nullptr) {}
  ~DeleteHostRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteHostRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteHostRequest(const DeleteHostRequest& from);
  DeleteHostRequest(DeleteHostRequest&& from) noexcept
    : DeleteHostRequest() {
    *this = ::std::move(from);
  }

  inline DeleteHostRequest& operator=(const DeleteHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteHostRequest& operator=(DeleteHostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteHostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteHostRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteHostRequest*>(
               &_DeleteHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteHostRequest& a, DeleteHostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteHostRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteHostRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteHostRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteHostRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteHostRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteHostRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteHostRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.DeleteHostRequest";
  }
  protected:
  explicit DeleteHostRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.DeleteHostRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListHostsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListHostsRequest) */ {
 public:
  inline ListHostsRequest() : ListHostsRequest(nullptr) {}
  ~ListHostsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListHostsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListHostsRequest(const ListHostsRequest& from);
  ListHostsRequest(ListHostsRequest&& from) noexcept
    : ListHostsRequest() {
    *this = ::std::move(from);
  }

  inline ListHostsRequest& operator=(const ListHostsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListHostsRequest& operator=(ListHostsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListHostsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListHostsRequest* internal_default_instance() {
    return reinterpret_cast<const ListHostsRequest*>(
               &_ListHostsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListHostsRequest& a, ListHostsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListHostsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListHostsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListHostsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListHostsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListHostsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListHostsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListHostsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListHostsRequest";
  }
  protected:
  explicit ListHostsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsIdsFieldNumber = 4,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // repeated string groups_ids = 4;
  int groups_ids_size() const;
  private:
  int _internal_groups_ids_size() const;
  public:
  void clear_groups_ids();
  const std::string& groups_ids(int index) const;
  std::string* mutable_groups_ids(int index);
  void set_groups_ids(int index, const std::string& value);
  void set_groups_ids(int index, std::string&& value);
  void set_groups_ids(int index, const char* value);
  void set_groups_ids(int index, const char* value, size_t size);
  std::string* add_groups_ids();
  void add_groups_ids(const std::string& value);
  void add_groups_ids(std::string&& value);
  void add_groups_ids(const char* value);
  void add_groups_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups_ids();
  private:
  const std::string& _internal_groups_ids(int index) const;
  std::string* _internal_add_groups_ids();
  public:

  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 1;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListHostsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListHostsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListHostsResponse) */ {
 public:
  inline ListHostsResponse() : ListHostsResponse(nullptr) {}
  ~ListHostsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListHostsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListHostsResponse(const ListHostsResponse& from);
  ListHostsResponse(ListHostsResponse&& from) noexcept
    : ListHostsResponse() {
    *this = ::std::move(from);
  }

  inline ListHostsResponse& operator=(const ListHostsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListHostsResponse& operator=(ListHostsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListHostsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListHostsResponse* internal_default_instance() {
    return reinterpret_cast<const ListHostsResponse*>(
               &_ListHostsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListHostsResponse& a, ListHostsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListHostsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListHostsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListHostsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListHostsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListHostsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListHostsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListHostsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListHostsResponse";
  }
  protected:
  explicit ListHostsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .zabmon.Host hosts = 1;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  ::zabmon::Host* mutable_hosts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Host >*
      mutable_hosts();
  private:
  const ::zabmon::Host& _internal_hosts(int index) const;
  ::zabmon::Host* _internal_add_hosts();
  public:
  const ::zabmon::Host& hosts(int index) const;
  ::zabmon::Host* add_hosts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Host >&
      hosts() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListHostsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Host > hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListGroupsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListGroupsRequest) */ {
 public:
  inline ListGroupsRequest() : ListGroupsRequest(nullptr) {}
  ~ListGroupsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListGroupsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListGroupsRequest(const ListGroupsRequest& from);
  ListGroupsRequest(ListGroupsRequest&& from) noexcept
    : ListGroupsRequest() {
    *this = ::std::move(from);
  }

  inline ListGroupsRequest& operator=(const ListGroupsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListGroupsRequest& operator=(ListGroupsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListGroupsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListGroupsRequest* internal_default_instance() {
    return reinterpret_cast<const ListGroupsRequest*>(
               &_ListGroupsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListGroupsRequest& a, ListGroupsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListGroupsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListGroupsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListGroupsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListGroupsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListGroupsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListGroupsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListGroupsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListGroupsRequest";
  }
  protected:
  explicit ListGroupsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 1;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListGroupsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListGroupsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListGroupsResponse) */ {
 public:
  inline ListGroupsResponse() : ListGroupsResponse(nullptr) {}
  ~ListGroupsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListGroupsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListGroupsResponse(const ListGroupsResponse& from);
  ListGroupsResponse(ListGroupsResponse&& from) noexcept
    : ListGroupsResponse() {
    *this = ::std::move(from);
  }

  inline ListGroupsResponse& operator=(const ListGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListGroupsResponse& operator=(ListGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListGroupsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListGroupsResponse* internal_default_instance() {
    return reinterpret_cast<const ListGroupsResponse*>(
               &_ListGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListGroupsResponse& a, ListGroupsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListGroupsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListGroupsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListGroupsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListGroupsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListGroupsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListGroupsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListGroupsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListGroupsResponse";
  }
  protected:
  explicit ListGroupsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .zabmon.Group groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::zabmon::Group* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Group >*
      mutable_groups();
  private:
  const ::zabmon::Group& _internal_groups(int index) const;
  ::zabmon::Group* _internal_add_groups();
  public:
  const ::zabmon::Group& groups(int index) const;
  ::zabmon::Group* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Group >&
      groups() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListGroupsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Group > groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.CreateGroupRequest) */ {
 public:
  inline CreateGroupRequest() : CreateGroupRequest(nullptr) {}
  ~CreateGroupRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupRequest(const CreateGroupRequest& from);
  CreateGroupRequest(CreateGroupRequest&& from) noexcept
    : CreateGroupRequest() {
    *this = ::std::move(from);
  }

  inline CreateGroupRequest& operator=(const CreateGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupRequest& operator=(CreateGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGroupRequest*>(
               &_CreateGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateGroupRequest& a, CreateGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.CreateGroupRequest";
  }
  protected:
  explicit CreateGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // .zabmon.Group group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::zabmon::Group& group() const;
  PROTOBUF_NODISCARD ::zabmon::Group* release_group();
  ::zabmon::Group* mutable_group();
  void set_allocated_group(::zabmon::Group* group);
  private:
  const ::zabmon::Group& _internal_group() const;
  ::zabmon::Group* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::zabmon::Group* group);
  ::zabmon::Group* unsafe_arena_release_group();

  // @@protoc_insertion_point(class_scope:zabmon.CreateGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zabmon::Group* group_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class DeleteGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.DeleteGroupRequest) */ {
 public:
  inline DeleteGroupRequest() : DeleteGroupRequest(nullptr) {}
  ~DeleteGroupRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteGroupRequest(const DeleteGroupRequest& from);
  DeleteGroupRequest(DeleteGroupRequest&& from) noexcept
    : DeleteGroupRequest() {
    *this = ::std::move(from);
  }

  inline DeleteGroupRequest& operator=(const DeleteGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteGroupRequest& operator=(DeleteGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteGroupRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteGroupRequest*>(
               &_DeleteGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeleteGroupRequest& a, DeleteGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.DeleteGroupRequest";
  }
  protected:
  explicit DeleteGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 3,
    kForceFieldNumber = 2,
  };
  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool force = 2;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.DeleteGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool force_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class CreateTemplateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.CreateTemplateRequest) */ {
 public:
  inline CreateTemplateRequest() : CreateTemplateRequest(nullptr) {}
  ~CreateTemplateRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTemplateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTemplateRequest(const CreateTemplateRequest& from);
  CreateTemplateRequest(CreateTemplateRequest&& from) noexcept
    : CreateTemplateRequest() {
    *this = ::std::move(from);
  }

  inline CreateTemplateRequest& operator=(const CreateTemplateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTemplateRequest& operator=(CreateTemplateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTemplateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTemplateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTemplateRequest*>(
               &_CreateTemplateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateTemplateRequest& a, CreateTemplateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTemplateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTemplateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTemplateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTemplateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTemplateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTemplateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTemplateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.CreateTemplateRequest";
  }
  protected:
  explicit CreateTemplateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemplateFieldNumber = 1,
  };
  // .zabmon.Template template = 1;
  bool has_template_() const;
  private:
  bool _internal_has_template_() const;
  public:
  void clear_template_();
  const ::zabmon::Template& template_() const;
  PROTOBUF_NODISCARD ::zabmon::Template* release_template_();
  ::zabmon::Template* mutable_template_();
  void set_allocated_template_(::zabmon::Template* template_);
  private:
  const ::zabmon::Template& _internal_template_() const;
  ::zabmon::Template* _internal_mutable_template_();
  public:
  void unsafe_arena_set_allocated_template_(
      ::zabmon::Template* template_);
  ::zabmon::Template* unsafe_arena_release_template_();

  // @@protoc_insertion_point(class_scope:zabmon.CreateTemplateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zabmon::Template* template__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class DeleteTemplateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.DeleteTemplateRequest) */ {
 public:
  inline DeleteTemplateRequest() : DeleteTemplateRequest(nullptr) {}
  ~DeleteTemplateRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteTemplateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTemplateRequest(const DeleteTemplateRequest& from);
  DeleteTemplateRequest(DeleteTemplateRequest&& from) noexcept
    : DeleteTemplateRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTemplateRequest& operator=(const DeleteTemplateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTemplateRequest& operator=(DeleteTemplateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTemplateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTemplateRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTemplateRequest*>(
               &_DeleteTemplateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteTemplateRequest& a, DeleteTemplateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTemplateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTemplateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTemplateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteTemplateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTemplateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteTemplateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTemplateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.DeleteTemplateRequest";
  }
  protected:
  explicit DeleteTemplateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 3,
    kForceFieldNumber = 2,
  };
  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool force = 2;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.DeleteTemplateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool force_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class CreateItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.CreateItemRequest) */ {
 public:
  inline CreateItemRequest() : CreateItemRequest(nullptr) {}
  ~CreateItemRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateItemRequest(const CreateItemRequest& from);
  CreateItemRequest(CreateItemRequest&& from) noexcept
    : CreateItemRequest() {
    *this = ::std::move(from);
  }

  inline CreateItemRequest& operator=(const CreateItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateItemRequest& operator=(CreateItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateItemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateItemRequest*>(
               &_CreateItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateItemRequest& a, CreateItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.CreateItemRequest";
  }
  protected:
  explicit CreateItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .zabmon.Item item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::zabmon::Item& item() const;
  PROTOBUF_NODISCARD ::zabmon::Item* release_item();
  ::zabmon::Item* mutable_item();
  void set_allocated_item(::zabmon::Item* item);
  private:
  const ::zabmon::Item& _internal_item() const;
  ::zabmon::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::zabmon::Item* item);
  ::zabmon::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:zabmon.CreateItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zabmon::Item* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class DeleteItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.DeleteItemRequest) */ {
 public:
  inline DeleteItemRequest() : DeleteItemRequest(nullptr) {}
  ~DeleteItemRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteItemRequest(const DeleteItemRequest& from);
  DeleteItemRequest(DeleteItemRequest&& from) noexcept
    : DeleteItemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteItemRequest& operator=(const DeleteItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItemRequest& operator=(DeleteItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteItemRequest*>(
               &_DeleteItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DeleteItemRequest& a, DeleteItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.DeleteItemRequest";
  }
  protected:
  explicit DeleteItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 3,
    kForceFieldNumber = 2,
  };
  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool force = 2;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.DeleteItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool force_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListItemsValuesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListItemsValuesRequest) */ {
 public:
  inline ListItemsValuesRequest() : ListItemsValuesRequest(nullptr) {}
  ~ListItemsValuesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListItemsValuesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListItemsValuesRequest(const ListItemsValuesRequest& from);
  ListItemsValuesRequest(ListItemsValuesRequest&& from) noexcept
    : ListItemsValuesRequest() {
    *this = ::std::move(from);
  }

  inline ListItemsValuesRequest& operator=(const ListItemsValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsValuesRequest& operator=(ListItemsValuesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsValuesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsValuesRequest* internal_default_instance() {
    return reinterpret_cast<const ListItemsValuesRequest*>(
               &_ListItemsValuesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListItemsValuesRequest& a, ListItemsValuesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsValuesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsValuesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsValuesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsValuesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListItemsValuesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListItemsValuesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListItemsValuesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListItemsValuesRequest";
  }
  protected:
  explicit ListItemsValuesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kPageTokenFieldNumber = 4,
    kLimitFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // repeated .zabmon.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::zabmon::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >*
      mutable_items();
  private:
  const ::zabmon::Item& _internal_items(int index) const;
  ::zabmon::Item* _internal_add_items();
  public:
  const ::zabmon::Item& items(int index) const;
  ::zabmon::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >&
      items() const;

  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 limit = 2;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListItemsValuesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item > items_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t limit_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListItemsValuesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListItemsValuesResponse) */ {
 public:
  inline ListItemsValuesResponse() : ListItemsValuesResponse(nullptr) {}
  ~ListItemsValuesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListItemsValuesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListItemsValuesResponse(const ListItemsValuesResponse& from);
  ListItemsValuesResponse(ListItemsValuesResponse&& from) noexcept
    : ListItemsValuesResponse() {
    *this = ::std::move(from);
  }

  inline ListItemsValuesResponse& operator=(const ListItemsValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsValuesResponse& operator=(ListItemsValuesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsValuesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsValuesResponse* internal_default_instance() {
    return reinterpret_cast<const ListItemsValuesResponse*>(
               &_ListItemsValuesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListItemsValuesResponse& a, ListItemsValuesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsValuesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsValuesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsValuesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsValuesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListItemsValuesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListItemsValuesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListItemsValuesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListItemsValuesResponse";
  }
  protected:
  explicit ListItemsValuesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .zabmon.ItemValues values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::zabmon::ItemValues* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::ItemValues >*
      mutable_values();
  private:
  const ::zabmon::ItemValues& _internal_values(int index) const;
  ::zabmon::ItemValues* _internal_add_values();
  public:
  const ::zabmon::ItemValues& values(int index) const;
  ::zabmon::ItemValues* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::ItemValues >&
      values() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListItemsValuesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::ItemValues > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListItemsRequest) */ {
 public:
  inline ListItemsRequest() : ListItemsRequest(nullptr) {}
  ~ListItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListItemsRequest(const ListItemsRequest& from);
  ListItemsRequest(ListItemsRequest&& from) noexcept
    : ListItemsRequest() {
    *this = ::std::move(from);
  }

  inline ListItemsRequest& operator=(const ListItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsRequest& operator=(ListItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListItemsRequest*>(
               &_ListItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ListItemsRequest& a, ListItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListItemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListItemsRequest";
  }
  protected:
  explicit ListItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsIdsFieldNumber = 6,
    kTemplatesIdsFieldNumber = 7,
    kHostsIdsFieldNumber = 8,
    kPageTokenFieldNumber = 5,
    kPageSizeFieldNumber = 4,
  };
  // repeated string groups_ids = 6;
  int groups_ids_size() const;
  private:
  int _internal_groups_ids_size() const;
  public:
  void clear_groups_ids();
  const std::string& groups_ids(int index) const;
  std::string* mutable_groups_ids(int index);
  void set_groups_ids(int index, const std::string& value);
  void set_groups_ids(int index, std::string&& value);
  void set_groups_ids(int index, const char* value);
  void set_groups_ids(int index, const char* value, size_t size);
  std::string* add_groups_ids();
  void add_groups_ids(const std::string& value);
  void add_groups_ids(std::string&& value);
  void add_groups_ids(const char* value);
  void add_groups_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups_ids();
  private:
  const std::string& _internal_groups_ids(int index) const;
  std::string* _internal_add_groups_ids();
  public:

  // repeated string templates_ids = 7;
  int templates_ids_size() const;
  private:
  int _internal_templates_ids_size() const;
  public:
  void clear_templates_ids();
  const std::string& templates_ids(int index) const;
  std::string* mutable_templates_ids(int index);
  void set_templates_ids(int index, const std::string& value);
  void set_templates_ids(int index, std::string&& value);
  void set_templates_ids(int index, const char* value);
  void set_templates_ids(int index, const char* value, size_t size);
  std::string* add_templates_ids();
  void add_templates_ids(const std::string& value);
  void add_templates_ids(std::string&& value);
  void add_templates_ids(const char* value);
  void add_templates_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& templates_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_templates_ids();
  private:
  const std::string& _internal_templates_ids(int index) const;
  std::string* _internal_add_templates_ids();
  public:

  // repeated string hosts_ids = 8;
  int hosts_ids_size() const;
  private:
  int _internal_hosts_ids_size() const;
  public:
  void clear_hosts_ids();
  const std::string& hosts_ids(int index) const;
  std::string* mutable_hosts_ids(int index);
  void set_hosts_ids(int index, const std::string& value);
  void set_hosts_ids(int index, std::string&& value);
  void set_hosts_ids(int index, const char* value);
  void set_hosts_ids(int index, const char* value, size_t size);
  std::string* add_hosts_ids();
  void add_hosts_ids(const std::string& value);
  void add_hosts_ids(std::string&& value);
  void add_hosts_ids(const char* value);
  void add_hosts_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts_ids();
  private:
  const std::string& _internal_hosts_ids(int index) const;
  std::string* _internal_add_hosts_ids();
  public:

  // string page_token = 5;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 4;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> templates_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListItemsResponse) */ {
 public:
  inline ListItemsResponse() : ListItemsResponse(nullptr) {}
  ~ListItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListItemsResponse(const ListItemsResponse& from);
  ListItemsResponse(ListItemsResponse&& from) noexcept
    : ListItemsResponse() {
    *this = ::std::move(from);
  }

  inline ListItemsResponse& operator=(const ListItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsResponse& operator=(ListItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListItemsResponse*>(
               &_ListItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ListItemsResponse& a, ListItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListItemsResponse";
  }
  protected:
  explicit ListItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .zabmon.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::zabmon::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >*
      mutable_items();
  private:
  const ::zabmon::Item& _internal_items(int index) const;
  ::zabmon::Item* _internal_add_items();
  public:
  const ::zabmon::Item& items(int index) const;
  ::zabmon::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >&
      items() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item > items_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListTemplatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListTemplatesRequest) */ {
 public:
  inline ListTemplatesRequest() : ListTemplatesRequest(nullptr) {}
  ~ListTemplatesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListTemplatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTemplatesRequest(const ListTemplatesRequest& from);
  ListTemplatesRequest(ListTemplatesRequest&& from) noexcept
    : ListTemplatesRequest() {
    *this = ::std::move(from);
  }

  inline ListTemplatesRequest& operator=(const ListTemplatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTemplatesRequest& operator=(ListTemplatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTemplatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTemplatesRequest* internal_default_instance() {
    return reinterpret_cast<const ListTemplatesRequest*>(
               &_ListTemplatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ListTemplatesRequest& a, ListTemplatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTemplatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTemplatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTemplatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTemplatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTemplatesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTemplatesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTemplatesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListTemplatesRequest";
  }
  protected:
  explicit ListTemplatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsIdsFieldNumber = 4,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // repeated string groups_ids = 4;
  int groups_ids_size() const;
  private:
  int _internal_groups_ids_size() const;
  public:
  void clear_groups_ids();
  const std::string& groups_ids(int index) const;
  std::string* mutable_groups_ids(int index);
  void set_groups_ids(int index, const std::string& value);
  void set_groups_ids(int index, std::string&& value);
  void set_groups_ids(int index, const char* value);
  void set_groups_ids(int index, const char* value, size_t size);
  std::string* add_groups_ids();
  void add_groups_ids(const std::string& value);
  void add_groups_ids(std::string&& value);
  void add_groups_ids(const char* value);
  void add_groups_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups_ids();
  private:
  const std::string& _internal_groups_ids(int index) const;
  std::string* _internal_add_groups_ids();
  public:

  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 1;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListTemplatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// -------------------------------------------------------------------

class ListTemplatesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zabmon.ListTemplatesResponse) */ {
 public:
  inline ListTemplatesResponse() : ListTemplatesResponse(nullptr) {}
  ~ListTemplatesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListTemplatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTemplatesResponse(const ListTemplatesResponse& from);
  ListTemplatesResponse(ListTemplatesResponse&& from) noexcept
    : ListTemplatesResponse() {
    *this = ::std::move(from);
  }

  inline ListTemplatesResponse& operator=(const ListTemplatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTemplatesResponse& operator=(ListTemplatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTemplatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTemplatesResponse* internal_default_instance() {
    return reinterpret_cast<const ListTemplatesResponse*>(
               &_ListTemplatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ListTemplatesResponse& a, ListTemplatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTemplatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTemplatesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTemplatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTemplatesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTemplatesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTemplatesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTemplatesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zabmon.ListTemplatesResponse";
  }
  protected:
  explicit ListTemplatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemplatesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .zabmon.Template templates = 1;
  int templates_size() const;
  private:
  int _internal_templates_size() const;
  public:
  void clear_templates();
  ::zabmon::Template* mutable_templates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Template >*
      mutable_templates();
  private:
  const ::zabmon::Template& _internal_templates(int index) const;
  ::zabmon::Template* _internal_add_templates();
  public:
  const ::zabmon::Template& templates(int index) const;
  ::zabmon::Template* add_templates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Template >&
      templates() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:zabmon.ListTemplatesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Template > templates_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zabmon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Item

// string metric_key = 2;
inline void Item::clear_metric_key() {
  metric_key_.ClearToEmpty();
}
inline const std::string& Item::metric_key() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.metric_key)
  return _internal_metric_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_metric_key(ArgT0&& arg0, ArgT... args) {
 
 metric_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Item.metric_key)
}
inline std::string* Item::mutable_metric_key() {
  std::string* _s = _internal_mutable_metric_key();
  // @@protoc_insertion_point(field_mutable:zabmon.Item.metric_key)
  return _s;
}
inline const std::string& Item::_internal_metric_key() const {
  return metric_key_.Get();
}
inline void Item::_internal_set_metric_key(const std::string& value) {
  
  metric_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_metric_key() {
  
  return metric_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_metric_key() {
  // @@protoc_insertion_point(field_release:zabmon.Item.metric_key)
  return metric_key_.Release();
}
inline void Item::set_allocated_metric_key(std::string* metric_key) {
  if (metric_key != nullptr) {
    
  } else {
    
  }
  metric_key_.SetAllocated(metric_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (metric_key_.IsDefault()) {
    metric_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Item.metric_key)
}

// .zabmon.ItemType type = 3;
inline void Item::clear_type() {
  type_ = 0;
}
inline ::zabmon::ItemType Item::_internal_type() const {
  return static_cast< ::zabmon::ItemType >(type_);
}
inline ::zabmon::ItemType Item::type() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.type)
  return _internal_type();
}
inline void Item::_internal_set_type(::zabmon::ItemType value) {
  
  type_ = value;
}
inline void Item::set_type(::zabmon::ItemType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zabmon.Item.type)
}

// .zabmon.ValueType value_type = 4;
inline void Item::clear_value_type() {
  value_type_ = 0;
}
inline ::zabmon::ValueType Item::_internal_value_type() const {
  return static_cast< ::zabmon::ValueType >(value_type_);
}
inline ::zabmon::ValueType Item::value_type() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.value_type)
  return _internal_value_type();
}
inline void Item::_internal_set_value_type(::zabmon::ValueType value) {
  
  value_type_ = value;
}
inline void Item::set_value_type(::zabmon::ValueType value) {
  _internal_set_value_type(value);
  // @@protoc_insertion_point(field_set:zabmon.Item.value_type)
}

// string delay = 5;
inline void Item::clear_delay() {
  delay_.ClearToEmpty();
}
inline const std::string& Item::delay() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.delay)
  return _internal_delay();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_delay(ArgT0&& arg0, ArgT... args) {
 
 delay_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Item.delay)
}
inline std::string* Item::mutable_delay() {
  std::string* _s = _internal_mutable_delay();
  // @@protoc_insertion_point(field_mutable:zabmon.Item.delay)
  return _s;
}
inline const std::string& Item::_internal_delay() const {
  return delay_.Get();
}
inline void Item::_internal_set_delay(const std::string& value) {
  
  delay_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_delay() {
  
  return delay_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_delay() {
  // @@protoc_insertion_point(field_release:zabmon.Item.delay)
  return delay_.Release();
}
inline void Item::set_allocated_delay(std::string* delay) {
  if (delay != nullptr) {
    
  } else {
    
  }
  delay_.SetAllocated(delay, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (delay_.IsDefault()) {
    delay_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Item.delay)
}

// string id = 6;
inline void Item::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Item::id() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Item.id)
}
inline std::string* Item::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Item.id)
  return _s;
}
inline const std::string& Item::_internal_id() const {
  return id_.Get();
}
inline void Item::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.Item.id)
  return id_.Release();
}
inline void Item::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Item.id)
}

// string interface_id = 7;
inline void Item::clear_interface_id() {
  interface_id_.ClearToEmpty();
}
inline const std::string& Item::interface_id() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.interface_id)
  return _internal_interface_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_interface_id(ArgT0&& arg0, ArgT... args) {
 
 interface_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Item.interface_id)
}
inline std::string* Item::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Item.interface_id)
  return _s;
}
inline const std::string& Item::_internal_interface_id() const {
  return interface_id_.Get();
}
inline void Item::_internal_set_interface_id(const std::string& value) {
  
  interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_interface_id() {
  
  return interface_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_interface_id() {
  // @@protoc_insertion_point(field_release:zabmon.Item.interface_id)
  return interface_id_.Release();
}
inline void Item::set_allocated_interface_id(std::string* interface_id) {
  if (interface_id != nullptr) {
    
  } else {
    
  }
  interface_id_.SetAllocated(interface_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (interface_id_.IsDefault()) {
    interface_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Item.interface_id)
}

// string name = 8;
inline void Item::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Item::name() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Item.name)
}
inline std::string* Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zabmon.Item.name)
  return _s;
}
inline const std::string& Item::_internal_name() const {
  return name_.Get();
}
inline void Item::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_name() {
  // @@protoc_insertion_point(field_release:zabmon.Item.name)
  return name_.Release();
}
inline void Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Item.name)
}

// string parent_id = 9;
inline void Item::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& Item::parent_id() const {
  // @@protoc_insertion_point(field_get:zabmon.Item.parent_id)
  return _internal_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_parent_id(ArgT0&& arg0, ArgT... args) {
 
 parent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Item.parent_id)
}
inline std::string* Item::mutable_parent_id() {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Item.parent_id)
  return _s;
}
inline const std::string& Item::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void Item::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_parent_id() {
  // @@protoc_insertion_point(field_release:zabmon.Item.parent_id)
  return parent_id_.Release();
}
inline void Item::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(parent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_id_.IsDefault()) {
    parent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Item.parent_id)
}

// -------------------------------------------------------------------

// ItemValues

// repeated .zabmon.Value values = 1;
inline int ItemValues::_internal_values_size() const {
  return values_.size();
}
inline int ItemValues::values_size() const {
  return _internal_values_size();
}
inline void ItemValues::clear_values() {
  values_.Clear();
}
inline ::zabmon::Value* ItemValues::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ItemValues.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Value >*
ItemValues::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ItemValues.values)
  return &values_;
}
inline const ::zabmon::Value& ItemValues::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::zabmon::Value& ItemValues::values(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ItemValues.values)
  return _internal_values(index);
}
inline ::zabmon::Value* ItemValues::_internal_add_values() {
  return values_.Add();
}
inline ::zabmon::Value* ItemValues::add_values() {
  ::zabmon::Value* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:zabmon.ItemValues.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Value >&
ItemValues::values() const {
  // @@protoc_insertion_point(field_list:zabmon.ItemValues.values)
  return values_;
}

// .zabmon.Item item = 2;
inline bool ItemValues::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool ItemValues::has_item() const {
  return _internal_has_item();
}
inline void ItemValues::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::zabmon::Item& ItemValues::_internal_item() const {
  const ::zabmon::Item* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::zabmon::Item&>(
      ::zabmon::_Item_default_instance_);
}
inline const ::zabmon::Item& ItemValues::item() const {
  // @@protoc_insertion_point(field_get:zabmon.ItemValues.item)
  return _internal_item();
}
inline void ItemValues::unsafe_arena_set_allocated_item(
    ::zabmon::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.ItemValues.item)
}
inline ::zabmon::Item* ItemValues::release_item() {
  
  ::zabmon::Item* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zabmon::Item* ItemValues::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:zabmon.ItemValues.item)
  
  ::zabmon::Item* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::zabmon::Item* ItemValues::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::zabmon::Item>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::zabmon::Item* ItemValues::mutable_item() {
  ::zabmon::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:zabmon.ItemValues.item)
  return _msg;
}
inline void ItemValues::set_allocated_item(::zabmon::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:zabmon.ItemValues.item)
}

// -------------------------------------------------------------------

// Value

// .google.protobuf.Timestamp timestamp = 1;
inline bool Value::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Value::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Value::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Value::timestamp() const {
  // @@protoc_insertion_point(field_get:zabmon.Value.timestamp)
  return _internal_timestamp();
}
inline void Value::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.Value.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Value::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Value::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:zabmon.Value.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Value::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Value::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:zabmon.Value.timestamp)
  return _msg;
}
inline void Value::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:zabmon.Value.timestamp)
}

// string value = 6;
inline void Value::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Value::value() const {
  // @@protoc_insertion_point(field_get:zabmon.Value.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Value.value)
}
inline std::string* Value::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zabmon.Value.value)
  return _s;
}
inline const std::string& Value::_internal_value() const {
  return value_.Get();
}
inline void Value::_internal_set_value(const std::string& value) {
  
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_value() {
  
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* Value::release_value() {
  // @@protoc_insertion_point(field_release:zabmon.Value.value)
  return value_.Release();
}
inline void Value::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Value.value)
}

// -------------------------------------------------------------------

// Group

// string name = 1;
inline void Group::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:zabmon.Group.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Group.name)
}
inline std::string* Group::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zabmon.Group.name)
  return _s;
}
inline const std::string& Group::_internal_name() const {
  return name_.Get();
}
inline void Group::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:zabmon.Group.name)
  return name_.Release();
}
inline void Group::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Group.name)
}

// repeated string templates_ids = 3;
inline int Group::_internal_templates_ids_size() const {
  return templates_ids_.size();
}
inline int Group::templates_ids_size() const {
  return _internal_templates_ids_size();
}
inline void Group::clear_templates_ids() {
  templates_ids_.Clear();
}
inline std::string* Group::add_templates_ids() {
  std::string* _s = _internal_add_templates_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.Group.templates_ids)
  return _s;
}
inline const std::string& Group::_internal_templates_ids(int index) const {
  return templates_ids_.Get(index);
}
inline const std::string& Group::templates_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.Group.templates_ids)
  return _internal_templates_ids(index);
}
inline std::string* Group::mutable_templates_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.Group.templates_ids)
  return templates_ids_.Mutable(index);
}
inline void Group::set_templates_ids(int index, const std::string& value) {
  templates_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.Group.templates_ids)
}
inline void Group::set_templates_ids(int index, std::string&& value) {
  templates_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.Group.templates_ids)
}
inline void Group::set_templates_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  templates_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.Group.templates_ids)
}
inline void Group::set_templates_ids(int index, const char* value, size_t size) {
  templates_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.Group.templates_ids)
}
inline std::string* Group::_internal_add_templates_ids() {
  return templates_ids_.Add();
}
inline void Group::add_templates_ids(const std::string& value) {
  templates_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.Group.templates_ids)
}
inline void Group::add_templates_ids(std::string&& value) {
  templates_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.Group.templates_ids)
}
inline void Group::add_templates_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  templates_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.Group.templates_ids)
}
inline void Group::add_templates_ids(const char* value, size_t size) {
  templates_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.Group.templates_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Group::templates_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.Group.templates_ids)
  return templates_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Group::mutable_templates_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.Group.templates_ids)
  return &templates_ids_;
}

// string id = 4;
inline void Group::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Group::id() const {
  // @@protoc_insertion_point(field_get:zabmon.Group.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Group.id)
}
inline std::string* Group::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Group.id)
  return _s;
}
inline const std::string& Group::_internal_id() const {
  return id_.Get();
}
inline void Group::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Group::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.Group.id)
  return id_.Release();
}
inline void Group::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Group.id)
}

// -------------------------------------------------------------------

// Interface

// string ip = 1;
inline void Interface::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Interface::ip() const {
  // @@protoc_insertion_point(field_get:zabmon.Interface.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Interface::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Interface.ip)
}
inline std::string* Interface::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:zabmon.Interface.ip)
  return _s;
}
inline const std::string& Interface::_internal_ip() const {
  return ip_.Get();
}
inline void Interface::_internal_set_ip(const std::string& value) {
  
  ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Interface::_internal_mutable_ip() {
  
  return ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Interface::release_ip() {
  // @@protoc_insertion_point(field_release:zabmon.Interface.ip)
  return ip_.Release();
}
inline void Interface::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault()) {
    ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Interface.ip)
}

// int32 port = 2;
inline void Interface::clear_port() {
  port_ = 0;
}
inline int32_t Interface::_internal_port() const {
  return port_;
}
inline int32_t Interface::port() const {
  // @@protoc_insertion_point(field_get:zabmon.Interface.port)
  return _internal_port();
}
inline void Interface::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void Interface::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:zabmon.Interface.port)
}

// string dns = 3;
inline void Interface::clear_dns() {
  dns_.ClearToEmpty();
}
inline const std::string& Interface::dns() const {
  // @@protoc_insertion_point(field_get:zabmon.Interface.dns)
  return _internal_dns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Interface::set_dns(ArgT0&& arg0, ArgT... args) {
 
 dns_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Interface.dns)
}
inline std::string* Interface::mutable_dns() {
  std::string* _s = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:zabmon.Interface.dns)
  return _s;
}
inline const std::string& Interface::_internal_dns() const {
  return dns_.Get();
}
inline void Interface::_internal_set_dns(const std::string& value) {
  
  dns_.Set(value, GetArenaForAllocation());
}
inline std::string* Interface::_internal_mutable_dns() {
  
  return dns_.Mutable(GetArenaForAllocation());
}
inline std::string* Interface::release_dns() {
  // @@protoc_insertion_point(field_release:zabmon.Interface.dns)
  return dns_.Release();
}
inline void Interface::set_allocated_dns(std::string* dns) {
  if (dns != nullptr) {
    
  } else {
    
  }
  dns_.SetAllocated(dns, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dns_.IsDefault()) {
    dns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Interface.dns)
}

// string id = 4;
inline void Interface::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Interface::id() const {
  // @@protoc_insertion_point(field_get:zabmon.Interface.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Interface::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Interface.id)
}
inline std::string* Interface::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Interface.id)
  return _s;
}
inline const std::string& Interface::_internal_id() const {
  return id_.Get();
}
inline void Interface::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Interface::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Interface::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.Interface.id)
  return id_.Release();
}
inline void Interface::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Interface.id)
}

// -------------------------------------------------------------------

// Template

// string name = 1;
inline void Template::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Template::name() const {
  // @@protoc_insertion_point(field_get:zabmon.Template.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Template::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Template.name)
}
inline std::string* Template::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zabmon.Template.name)
  return _s;
}
inline const std::string& Template::_internal_name() const {
  return name_.Get();
}
inline void Template::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Template::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Template::release_name() {
  // @@protoc_insertion_point(field_release:zabmon.Template.name)
  return name_.Release();
}
inline void Template::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Template.name)
}

// repeated string groups_ids = 3;
inline int Template::_internal_groups_ids_size() const {
  return groups_ids_.size();
}
inline int Template::groups_ids_size() const {
  return _internal_groups_ids_size();
}
inline void Template::clear_groups_ids() {
  groups_ids_.Clear();
}
inline std::string* Template::add_groups_ids() {
  std::string* _s = _internal_add_groups_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.Template.groups_ids)
  return _s;
}
inline const std::string& Template::_internal_groups_ids(int index) const {
  return groups_ids_.Get(index);
}
inline const std::string& Template::groups_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.Template.groups_ids)
  return _internal_groups_ids(index);
}
inline std::string* Template::mutable_groups_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.Template.groups_ids)
  return groups_ids_.Mutable(index);
}
inline void Template::set_groups_ids(int index, const std::string& value) {
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.Template.groups_ids)
}
inline void Template::set_groups_ids(int index, std::string&& value) {
  groups_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.Template.groups_ids)
}
inline void Template::set_groups_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.Template.groups_ids)
}
inline void Template::set_groups_ids(int index, const char* value, size_t size) {
  groups_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.Template.groups_ids)
}
inline std::string* Template::_internal_add_groups_ids() {
  return groups_ids_.Add();
}
inline void Template::add_groups_ids(const std::string& value) {
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.Template.groups_ids)
}
inline void Template::add_groups_ids(std::string&& value) {
  groups_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.Template.groups_ids)
}
inline void Template::add_groups_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.Template.groups_ids)
}
inline void Template::add_groups_ids(const char* value, size_t size) {
  groups_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.Template.groups_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Template::groups_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.Template.groups_ids)
  return groups_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Template::mutable_groups_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.Template.groups_ids)
  return &groups_ids_;
}

// string id = 4;
inline void Template::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Template::id() const {
  // @@protoc_insertion_point(field_get:zabmon.Template.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Template::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Template.id)
}
inline std::string* Template::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Template.id)
  return _s;
}
inline const std::string& Template::_internal_id() const {
  return id_.Get();
}
inline void Template::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Template::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Template::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.Template.id)
  return id_.Release();
}
inline void Template::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Template.id)
}

// -------------------------------------------------------------------

// Host

// string name = 1;
inline void Host::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Host::name() const {
  // @@protoc_insertion_point(field_get:zabmon.Host.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Host::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Host.name)
}
inline std::string* Host::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zabmon.Host.name)
  return _s;
}
inline const std::string& Host::_internal_name() const {
  return name_.Get();
}
inline void Host::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Host::release_name() {
  // @@protoc_insertion_point(field_release:zabmon.Host.name)
  return name_.Release();
}
inline void Host::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Host.name)
}

// repeated .zabmon.Interface interfaces = 2;
inline int Host::_internal_interfaces_size() const {
  return interfaces_.size();
}
inline int Host::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void Host::clear_interfaces() {
  interfaces_.Clear();
}
inline ::zabmon::Interface* Host::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.Host.interfaces)
  return interfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Interface >*
Host::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.Host.interfaces)
  return &interfaces_;
}
inline const ::zabmon::Interface& Host::_internal_interfaces(int index) const {
  return interfaces_.Get(index);
}
inline const ::zabmon::Interface& Host::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.Host.interfaces)
  return _internal_interfaces(index);
}
inline ::zabmon::Interface* Host::_internal_add_interfaces() {
  return interfaces_.Add();
}
inline ::zabmon::Interface* Host::add_interfaces() {
  ::zabmon::Interface* _add = _internal_add_interfaces();
  // @@protoc_insertion_point(field_add:zabmon.Host.interfaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Interface >&
Host::interfaces() const {
  // @@protoc_insertion_point(field_list:zabmon.Host.interfaces)
  return interfaces_;
}

// repeated string groups_ids = 5;
inline int Host::_internal_groups_ids_size() const {
  return groups_ids_.size();
}
inline int Host::groups_ids_size() const {
  return _internal_groups_ids_size();
}
inline void Host::clear_groups_ids() {
  groups_ids_.Clear();
}
inline std::string* Host::add_groups_ids() {
  std::string* _s = _internal_add_groups_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.Host.groups_ids)
  return _s;
}
inline const std::string& Host::_internal_groups_ids(int index) const {
  return groups_ids_.Get(index);
}
inline const std::string& Host::groups_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.Host.groups_ids)
  return _internal_groups_ids(index);
}
inline std::string* Host::mutable_groups_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.Host.groups_ids)
  return groups_ids_.Mutable(index);
}
inline void Host::set_groups_ids(int index, const std::string& value) {
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.Host.groups_ids)
}
inline void Host::set_groups_ids(int index, std::string&& value) {
  groups_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.Host.groups_ids)
}
inline void Host::set_groups_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.Host.groups_ids)
}
inline void Host::set_groups_ids(int index, const char* value, size_t size) {
  groups_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.Host.groups_ids)
}
inline std::string* Host::_internal_add_groups_ids() {
  return groups_ids_.Add();
}
inline void Host::add_groups_ids(const std::string& value) {
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.Host.groups_ids)
}
inline void Host::add_groups_ids(std::string&& value) {
  groups_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.Host.groups_ids)
}
inline void Host::add_groups_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.Host.groups_ids)
}
inline void Host::add_groups_ids(const char* value, size_t size) {
  groups_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.Host.groups_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Host::groups_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.Host.groups_ids)
  return groups_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Host::mutable_groups_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.Host.groups_ids)
  return &groups_ids_;
}

// repeated string templates_ids = 6;
inline int Host::_internal_templates_ids_size() const {
  return templates_ids_.size();
}
inline int Host::templates_ids_size() const {
  return _internal_templates_ids_size();
}
inline void Host::clear_templates_ids() {
  templates_ids_.Clear();
}
inline std::string* Host::add_templates_ids() {
  std::string* _s = _internal_add_templates_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.Host.templates_ids)
  return _s;
}
inline const std::string& Host::_internal_templates_ids(int index) const {
  return templates_ids_.Get(index);
}
inline const std::string& Host::templates_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.Host.templates_ids)
  return _internal_templates_ids(index);
}
inline std::string* Host::mutable_templates_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.Host.templates_ids)
  return templates_ids_.Mutable(index);
}
inline void Host::set_templates_ids(int index, const std::string& value) {
  templates_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.Host.templates_ids)
}
inline void Host::set_templates_ids(int index, std::string&& value) {
  templates_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.Host.templates_ids)
}
inline void Host::set_templates_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  templates_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.Host.templates_ids)
}
inline void Host::set_templates_ids(int index, const char* value, size_t size) {
  templates_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.Host.templates_ids)
}
inline std::string* Host::_internal_add_templates_ids() {
  return templates_ids_.Add();
}
inline void Host::add_templates_ids(const std::string& value) {
  templates_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.Host.templates_ids)
}
inline void Host::add_templates_ids(std::string&& value) {
  templates_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.Host.templates_ids)
}
inline void Host::add_templates_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  templates_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.Host.templates_ids)
}
inline void Host::add_templates_ids(const char* value, size_t size) {
  templates_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.Host.templates_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Host::templates_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.Host.templates_ids)
  return templates_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Host::mutable_templates_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.Host.templates_ids)
  return &templates_ids_;
}

// string id = 7;
inline void Host::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Host::id() const {
  // @@protoc_insertion_point(field_get:zabmon.Host.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Host::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.Host.id)
}
inline std::string* Host::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.Host.id)
  return _s;
}
inline const std::string& Host::_internal_id() const {
  return id_.Get();
}
inline void Host::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Host::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.Host.id)
  return id_.Release();
}
inline void Host::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.Host.id)
}

// -------------------------------------------------------------------

// CreateHostRequest

// .zabmon.Host host = 1;
inline bool CreateHostRequest::_internal_has_host() const {
  return this != internal_default_instance() && host_ != nullptr;
}
inline bool CreateHostRequest::has_host() const {
  return _internal_has_host();
}
inline void CreateHostRequest::clear_host() {
  if (GetArenaForAllocation() == nullptr && host_ != nullptr) {
    delete host_;
  }
  host_ = nullptr;
}
inline const ::zabmon::Host& CreateHostRequest::_internal_host() const {
  const ::zabmon::Host* p = host_;
  return p != nullptr ? *p : reinterpret_cast<const ::zabmon::Host&>(
      ::zabmon::_Host_default_instance_);
}
inline const ::zabmon::Host& CreateHostRequest::host() const {
  // @@protoc_insertion_point(field_get:zabmon.CreateHostRequest.host)
  return _internal_host();
}
inline void CreateHostRequest::unsafe_arena_set_allocated_host(
    ::zabmon::Host* host) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(host_);
  }
  host_ = host;
  if (host) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.CreateHostRequest.host)
}
inline ::zabmon::Host* CreateHostRequest::release_host() {
  
  ::zabmon::Host* temp = host_;
  host_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zabmon::Host* CreateHostRequest::unsafe_arena_release_host() {
  // @@protoc_insertion_point(field_release:zabmon.CreateHostRequest.host)
  
  ::zabmon::Host* temp = host_;
  host_ = nullptr;
  return temp;
}
inline ::zabmon::Host* CreateHostRequest::_internal_mutable_host() {
  
  if (host_ == nullptr) {
    auto* p = CreateMaybeMessage<::zabmon::Host>(GetArenaForAllocation());
    host_ = p;
  }
  return host_;
}
inline ::zabmon::Host* CreateHostRequest::mutable_host() {
  ::zabmon::Host* _msg = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:zabmon.CreateHostRequest.host)
  return _msg;
}
inline void CreateHostRequest::set_allocated_host(::zabmon::Host* host) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete host_;
  }
  if (host) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host);
    if (message_arena != submessage_arena) {
      host = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host, submessage_arena);
    }
    
  } else {
    
  }
  host_ = host;
  // @@protoc_insertion_point(field_set_allocated:zabmon.CreateHostRequest.host)
}

// -------------------------------------------------------------------

// UpdateHostRequest

// .zabmon.Host host = 1;
inline bool UpdateHostRequest::_internal_has_host() const {
  return this != internal_default_instance() && host_ != nullptr;
}
inline bool UpdateHostRequest::has_host() const {
  return _internal_has_host();
}
inline void UpdateHostRequest::clear_host() {
  if (GetArenaForAllocation() == nullptr && host_ != nullptr) {
    delete host_;
  }
  host_ = nullptr;
}
inline const ::zabmon::Host& UpdateHostRequest::_internal_host() const {
  const ::zabmon::Host* p = host_;
  return p != nullptr ? *p : reinterpret_cast<const ::zabmon::Host&>(
      ::zabmon::_Host_default_instance_);
}
inline const ::zabmon::Host& UpdateHostRequest::host() const {
  // @@protoc_insertion_point(field_get:zabmon.UpdateHostRequest.host)
  return _internal_host();
}
inline void UpdateHostRequest::unsafe_arena_set_allocated_host(
    ::zabmon::Host* host) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(host_);
  }
  host_ = host;
  if (host) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.UpdateHostRequest.host)
}
inline ::zabmon::Host* UpdateHostRequest::release_host() {
  
  ::zabmon::Host* temp = host_;
  host_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zabmon::Host* UpdateHostRequest::unsafe_arena_release_host() {
  // @@protoc_insertion_point(field_release:zabmon.UpdateHostRequest.host)
  
  ::zabmon::Host* temp = host_;
  host_ = nullptr;
  return temp;
}
inline ::zabmon::Host* UpdateHostRequest::_internal_mutable_host() {
  
  if (host_ == nullptr) {
    auto* p = CreateMaybeMessage<::zabmon::Host>(GetArenaForAllocation());
    host_ = p;
  }
  return host_;
}
inline ::zabmon::Host* UpdateHostRequest::mutable_host() {
  ::zabmon::Host* _msg = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:zabmon.UpdateHostRequest.host)
  return _msg;
}
inline void UpdateHostRequest::set_allocated_host(::zabmon::Host* host) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete host_;
  }
  if (host) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host);
    if (message_arena != submessage_arena) {
      host = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host, submessage_arena);
    }
    
  } else {
    
  }
  host_ = host;
  // @@protoc_insertion_point(field_set_allocated:zabmon.UpdateHostRequest.host)
}

// -------------------------------------------------------------------

// DeleteHostRequest

// string id = 2;
inline void DeleteHostRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteHostRequest::id() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteHostRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteHostRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.DeleteHostRequest.id)
}
inline std::string* DeleteHostRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.DeleteHostRequest.id)
  return _s;
}
inline const std::string& DeleteHostRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteHostRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteHostRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteHostRequest::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.DeleteHostRequest.id)
  return id_.Release();
}
inline void DeleteHostRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.DeleteHostRequest.id)
}

// -------------------------------------------------------------------

// ListHostsRequest

// int32 page_size = 1;
inline void ListHostsRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListHostsRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListHostsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:zabmon.ListHostsRequest.page_size)
  return _internal_page_size();
}
inline void ListHostsRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListHostsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:zabmon.ListHostsRequest.page_size)
}

// string page_token = 2;
inline void ListHostsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListHostsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListHostsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListHostsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListHostsRequest.page_token)
}
inline std::string* ListHostsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListHostsRequest.page_token)
  return _s;
}
inline const std::string& ListHostsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListHostsRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListHostsRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListHostsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListHostsRequest.page_token)
  return page_token_.Release();
}
inline void ListHostsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListHostsRequest.page_token)
}

// repeated string groups_ids = 4;
inline int ListHostsRequest::_internal_groups_ids_size() const {
  return groups_ids_.size();
}
inline int ListHostsRequest::groups_ids_size() const {
  return _internal_groups_ids_size();
}
inline void ListHostsRequest::clear_groups_ids() {
  groups_ids_.Clear();
}
inline std::string* ListHostsRequest::add_groups_ids() {
  std::string* _s = _internal_add_groups_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.ListHostsRequest.groups_ids)
  return _s;
}
inline const std::string& ListHostsRequest::_internal_groups_ids(int index) const {
  return groups_ids_.Get(index);
}
inline const std::string& ListHostsRequest::groups_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListHostsRequest.groups_ids)
  return _internal_groups_ids(index);
}
inline std::string* ListHostsRequest::mutable_groups_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListHostsRequest.groups_ids)
  return groups_ids_.Mutable(index);
}
inline void ListHostsRequest::set_groups_ids(int index, const std::string& value) {
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.ListHostsRequest.groups_ids)
}
inline void ListHostsRequest::set_groups_ids(int index, std::string&& value) {
  groups_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.ListHostsRequest.groups_ids)
}
inline void ListHostsRequest::set_groups_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.ListHostsRequest.groups_ids)
}
inline void ListHostsRequest::set_groups_ids(int index, const char* value, size_t size) {
  groups_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.ListHostsRequest.groups_ids)
}
inline std::string* ListHostsRequest::_internal_add_groups_ids() {
  return groups_ids_.Add();
}
inline void ListHostsRequest::add_groups_ids(const std::string& value) {
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.ListHostsRequest.groups_ids)
}
inline void ListHostsRequest::add_groups_ids(std::string&& value) {
  groups_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.ListHostsRequest.groups_ids)
}
inline void ListHostsRequest::add_groups_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.ListHostsRequest.groups_ids)
}
inline void ListHostsRequest::add_groups_ids(const char* value, size_t size) {
  groups_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.ListHostsRequest.groups_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListHostsRequest::groups_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.ListHostsRequest.groups_ids)
  return groups_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListHostsRequest::mutable_groups_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListHostsRequest.groups_ids)
  return &groups_ids_;
}

// -------------------------------------------------------------------

// ListHostsResponse

// repeated .zabmon.Host hosts = 1;
inline int ListHostsResponse::_internal_hosts_size() const {
  return hosts_.size();
}
inline int ListHostsResponse::hosts_size() const {
  return _internal_hosts_size();
}
inline void ListHostsResponse::clear_hosts() {
  hosts_.Clear();
}
inline ::zabmon::Host* ListHostsResponse::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListHostsResponse.hosts)
  return hosts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Host >*
ListHostsResponse::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListHostsResponse.hosts)
  return &hosts_;
}
inline const ::zabmon::Host& ListHostsResponse::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const ::zabmon::Host& ListHostsResponse::hosts(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListHostsResponse.hosts)
  return _internal_hosts(index);
}
inline ::zabmon::Host* ListHostsResponse::_internal_add_hosts() {
  return hosts_.Add();
}
inline ::zabmon::Host* ListHostsResponse::add_hosts() {
  ::zabmon::Host* _add = _internal_add_hosts();
  // @@protoc_insertion_point(field_add:zabmon.ListHostsResponse.hosts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Host >&
ListHostsResponse::hosts() const {
  // @@protoc_insertion_point(field_list:zabmon.ListHostsResponse.hosts)
  return hosts_;
}

// string next_page_token = 2;
inline void ListHostsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListHostsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListHostsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListHostsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListHostsResponse.next_page_token)
}
inline std::string* ListHostsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListHostsResponse.next_page_token)
  return _s;
}
inline const std::string& ListHostsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListHostsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListHostsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListHostsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListHostsResponse.next_page_token)
  return next_page_token_.Release();
}
inline void ListHostsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListHostsResponse.next_page_token)
}

// -------------------------------------------------------------------

// ListGroupsRequest

// int32 page_size = 1;
inline void ListGroupsRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListGroupsRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListGroupsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:zabmon.ListGroupsRequest.page_size)
  return _internal_page_size();
}
inline void ListGroupsRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListGroupsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:zabmon.ListGroupsRequest.page_size)
}

// string page_token = 2;
inline void ListGroupsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListGroupsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListGroupsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListGroupsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListGroupsRequest.page_token)
}
inline std::string* ListGroupsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListGroupsRequest.page_token)
  return _s;
}
inline const std::string& ListGroupsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListGroupsRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListGroupsRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListGroupsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListGroupsRequest.page_token)
  return page_token_.Release();
}
inline void ListGroupsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListGroupsRequest.page_token)
}

// -------------------------------------------------------------------

// ListGroupsResponse

// repeated .zabmon.Group groups = 1;
inline int ListGroupsResponse::_internal_groups_size() const {
  return groups_.size();
}
inline int ListGroupsResponse::groups_size() const {
  return _internal_groups_size();
}
inline void ListGroupsResponse::clear_groups() {
  groups_.Clear();
}
inline ::zabmon::Group* ListGroupsResponse::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListGroupsResponse.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Group >*
ListGroupsResponse::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListGroupsResponse.groups)
  return &groups_;
}
inline const ::zabmon::Group& ListGroupsResponse::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::zabmon::Group& ListGroupsResponse::groups(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListGroupsResponse.groups)
  return _internal_groups(index);
}
inline ::zabmon::Group* ListGroupsResponse::_internal_add_groups() {
  return groups_.Add();
}
inline ::zabmon::Group* ListGroupsResponse::add_groups() {
  ::zabmon::Group* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:zabmon.ListGroupsResponse.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Group >&
ListGroupsResponse::groups() const {
  // @@protoc_insertion_point(field_list:zabmon.ListGroupsResponse.groups)
  return groups_;
}

// string next_page_token = 2;
inline void ListGroupsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListGroupsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListGroupsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListGroupsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListGroupsResponse.next_page_token)
}
inline std::string* ListGroupsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListGroupsResponse.next_page_token)
  return _s;
}
inline const std::string& ListGroupsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListGroupsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListGroupsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListGroupsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListGroupsResponse.next_page_token)
  return next_page_token_.Release();
}
inline void ListGroupsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListGroupsResponse.next_page_token)
}

// -------------------------------------------------------------------

// CreateGroupRequest

// .zabmon.Group group = 1;
inline bool CreateGroupRequest::_internal_has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline bool CreateGroupRequest::has_group() const {
  return _internal_has_group();
}
inline void CreateGroupRequest::clear_group() {
  if (GetArenaForAllocation() == nullptr && group_ != nullptr) {
    delete group_;
  }
  group_ = nullptr;
}
inline const ::zabmon::Group& CreateGroupRequest::_internal_group() const {
  const ::zabmon::Group* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::zabmon::Group&>(
      ::zabmon::_Group_default_instance_);
}
inline const ::zabmon::Group& CreateGroupRequest::group() const {
  // @@protoc_insertion_point(field_get:zabmon.CreateGroupRequest.group)
  return _internal_group();
}
inline void CreateGroupRequest::unsafe_arena_set_allocated_group(
    ::zabmon::Group* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.CreateGroupRequest.group)
}
inline ::zabmon::Group* CreateGroupRequest::release_group() {
  
  ::zabmon::Group* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zabmon::Group* CreateGroupRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:zabmon.CreateGroupRequest.group)
  
  ::zabmon::Group* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::zabmon::Group* CreateGroupRequest::_internal_mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::zabmon::Group>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::zabmon::Group* CreateGroupRequest::mutable_group() {
  ::zabmon::Group* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:zabmon.CreateGroupRequest.group)
  return _msg;
}
inline void CreateGroupRequest::set_allocated_group(::zabmon::Group* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:zabmon.CreateGroupRequest.group)
}

// -------------------------------------------------------------------

// DeleteGroupRequest

// bool force = 2;
inline void DeleteGroupRequest::clear_force() {
  force_ = false;
}
inline bool DeleteGroupRequest::_internal_force() const {
  return force_;
}
inline bool DeleteGroupRequest::force() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteGroupRequest.force)
  return _internal_force();
}
inline void DeleteGroupRequest::_internal_set_force(bool value) {
  
  force_ = value;
}
inline void DeleteGroupRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:zabmon.DeleteGroupRequest.force)
}

// string id = 3;
inline void DeleteGroupRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteGroupRequest::id() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteGroupRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteGroupRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.DeleteGroupRequest.id)
}
inline std::string* DeleteGroupRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.DeleteGroupRequest.id)
  return _s;
}
inline const std::string& DeleteGroupRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteGroupRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteGroupRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteGroupRequest::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.DeleteGroupRequest.id)
  return id_.Release();
}
inline void DeleteGroupRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.DeleteGroupRequest.id)
}

// -------------------------------------------------------------------

// CreateTemplateRequest

// .zabmon.Template template = 1;
inline bool CreateTemplateRequest::_internal_has_template_() const {
  return this != internal_default_instance() && template__ != nullptr;
}
inline bool CreateTemplateRequest::has_template_() const {
  return _internal_has_template_();
}
inline void CreateTemplateRequest::clear_template_() {
  if (GetArenaForAllocation() == nullptr && template__ != nullptr) {
    delete template__;
  }
  template__ = nullptr;
}
inline const ::zabmon::Template& CreateTemplateRequest::_internal_template_() const {
  const ::zabmon::Template* p = template__;
  return p != nullptr ? *p : reinterpret_cast<const ::zabmon::Template&>(
      ::zabmon::_Template_default_instance_);
}
inline const ::zabmon::Template& CreateTemplateRequest::template_() const {
  // @@protoc_insertion_point(field_get:zabmon.CreateTemplateRequest.template)
  return _internal_template_();
}
inline void CreateTemplateRequest::unsafe_arena_set_allocated_template_(
    ::zabmon::Template* template_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(template__);
  }
  template__ = template_;
  if (template_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.CreateTemplateRequest.template)
}
inline ::zabmon::Template* CreateTemplateRequest::release_template_() {
  
  ::zabmon::Template* temp = template__;
  template__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zabmon::Template* CreateTemplateRequest::unsafe_arena_release_template_() {
  // @@protoc_insertion_point(field_release:zabmon.CreateTemplateRequest.template)
  
  ::zabmon::Template* temp = template__;
  template__ = nullptr;
  return temp;
}
inline ::zabmon::Template* CreateTemplateRequest::_internal_mutable_template_() {
  
  if (template__ == nullptr) {
    auto* p = CreateMaybeMessage<::zabmon::Template>(GetArenaForAllocation());
    template__ = p;
  }
  return template__;
}
inline ::zabmon::Template* CreateTemplateRequest::mutable_template_() {
  ::zabmon::Template* _msg = _internal_mutable_template_();
  // @@protoc_insertion_point(field_mutable:zabmon.CreateTemplateRequest.template)
  return _msg;
}
inline void CreateTemplateRequest::set_allocated_template_(::zabmon::Template* template_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete template__;
  }
  if (template_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(template_);
    if (message_arena != submessage_arena) {
      template_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, template_, submessage_arena);
    }
    
  } else {
    
  }
  template__ = template_;
  // @@protoc_insertion_point(field_set_allocated:zabmon.CreateTemplateRequest.template)
}

// -------------------------------------------------------------------

// DeleteTemplateRequest

// bool force = 2;
inline void DeleteTemplateRequest::clear_force() {
  force_ = false;
}
inline bool DeleteTemplateRequest::_internal_force() const {
  return force_;
}
inline bool DeleteTemplateRequest::force() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteTemplateRequest.force)
  return _internal_force();
}
inline void DeleteTemplateRequest::_internal_set_force(bool value) {
  
  force_ = value;
}
inline void DeleteTemplateRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:zabmon.DeleteTemplateRequest.force)
}

// string id = 3;
inline void DeleteTemplateRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteTemplateRequest::id() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteTemplateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTemplateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.DeleteTemplateRequest.id)
}
inline std::string* DeleteTemplateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.DeleteTemplateRequest.id)
  return _s;
}
inline const std::string& DeleteTemplateRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteTemplateRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteTemplateRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteTemplateRequest::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.DeleteTemplateRequest.id)
  return id_.Release();
}
inline void DeleteTemplateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.DeleteTemplateRequest.id)
}

// -------------------------------------------------------------------

// CreateItemRequest

// .zabmon.Item item = 1;
inline bool CreateItemRequest::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool CreateItemRequest::has_item() const {
  return _internal_has_item();
}
inline void CreateItemRequest::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::zabmon::Item& CreateItemRequest::_internal_item() const {
  const ::zabmon::Item* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::zabmon::Item&>(
      ::zabmon::_Item_default_instance_);
}
inline const ::zabmon::Item& CreateItemRequest::item() const {
  // @@protoc_insertion_point(field_get:zabmon.CreateItemRequest.item)
  return _internal_item();
}
inline void CreateItemRequest::unsafe_arena_set_allocated_item(
    ::zabmon::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zabmon.CreateItemRequest.item)
}
inline ::zabmon::Item* CreateItemRequest::release_item() {
  
  ::zabmon::Item* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zabmon::Item* CreateItemRequest::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:zabmon.CreateItemRequest.item)
  
  ::zabmon::Item* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::zabmon::Item* CreateItemRequest::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::zabmon::Item>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::zabmon::Item* CreateItemRequest::mutable_item() {
  ::zabmon::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:zabmon.CreateItemRequest.item)
  return _msg;
}
inline void CreateItemRequest::set_allocated_item(::zabmon::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:zabmon.CreateItemRequest.item)
}

// -------------------------------------------------------------------

// DeleteItemRequest

// bool force = 2;
inline void DeleteItemRequest::clear_force() {
  force_ = false;
}
inline bool DeleteItemRequest::_internal_force() const {
  return force_;
}
inline bool DeleteItemRequest::force() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteItemRequest.force)
  return _internal_force();
}
inline void DeleteItemRequest::_internal_set_force(bool value) {
  
  force_ = value;
}
inline void DeleteItemRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:zabmon.DeleteItemRequest.force)
}

// string id = 3;
inline void DeleteItemRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteItemRequest::id() const {
  // @@protoc_insertion_point(field_get:zabmon.DeleteItemRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteItemRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.DeleteItemRequest.id)
}
inline std::string* DeleteItemRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zabmon.DeleteItemRequest.id)
  return _s;
}
inline const std::string& DeleteItemRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteItemRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteItemRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteItemRequest::release_id() {
  // @@protoc_insertion_point(field_release:zabmon.DeleteItemRequest.id)
  return id_.Release();
}
inline void DeleteItemRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.DeleteItemRequest.id)
}

// -------------------------------------------------------------------

// ListItemsValuesRequest

// repeated .zabmon.Item items = 1;
inline int ListItemsValuesRequest::_internal_items_size() const {
  return items_.size();
}
inline int ListItemsValuesRequest::items_size() const {
  return _internal_items_size();
}
inline void ListItemsValuesRequest::clear_items() {
  items_.Clear();
}
inline ::zabmon::Item* ListItemsValuesRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsValuesRequest.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >*
ListItemsValuesRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListItemsValuesRequest.items)
  return &items_;
}
inline const ::zabmon::Item& ListItemsValuesRequest::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::zabmon::Item& ListItemsValuesRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsValuesRequest.items)
  return _internal_items(index);
}
inline ::zabmon::Item* ListItemsValuesRequest::_internal_add_items() {
  return items_.Add();
}
inline ::zabmon::Item* ListItemsValuesRequest::add_items() {
  ::zabmon::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:zabmon.ListItemsValuesRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >&
ListItemsValuesRequest::items() const {
  // @@protoc_insertion_point(field_list:zabmon.ListItemsValuesRequest.items)
  return items_;
}

// int32 limit = 2;
inline void ListItemsValuesRequest::clear_limit() {
  limit_ = 0;
}
inline int32_t ListItemsValuesRequest::_internal_limit() const {
  return limit_;
}
inline int32_t ListItemsValuesRequest::limit() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsValuesRequest.limit)
  return _internal_limit();
}
inline void ListItemsValuesRequest::_internal_set_limit(int32_t value) {
  
  limit_ = value;
}
inline void ListItemsValuesRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:zabmon.ListItemsValuesRequest.limit)
}

// int32 page_size = 3;
inline void ListItemsValuesRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListItemsValuesRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListItemsValuesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsValuesRequest.page_size)
  return _internal_page_size();
}
inline void ListItemsValuesRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListItemsValuesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:zabmon.ListItemsValuesRequest.page_size)
}

// string page_token = 4;
inline void ListItemsValuesRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListItemsValuesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsValuesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListItemsValuesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListItemsValuesRequest.page_token)
}
inline std::string* ListItemsValuesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsValuesRequest.page_token)
  return _s;
}
inline const std::string& ListItemsValuesRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListItemsValuesRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListItemsValuesRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListItemsValuesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListItemsValuesRequest.page_token)
  return page_token_.Release();
}
inline void ListItemsValuesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListItemsValuesRequest.page_token)
}

// -------------------------------------------------------------------

// ListItemsValuesResponse

// repeated .zabmon.ItemValues values = 1;
inline int ListItemsValuesResponse::_internal_values_size() const {
  return values_.size();
}
inline int ListItemsValuesResponse::values_size() const {
  return _internal_values_size();
}
inline void ListItemsValuesResponse::clear_values() {
  values_.Clear();
}
inline ::zabmon::ItemValues* ListItemsValuesResponse::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsValuesResponse.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::ItemValues >*
ListItemsValuesResponse::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListItemsValuesResponse.values)
  return &values_;
}
inline const ::zabmon::ItemValues& ListItemsValuesResponse::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::zabmon::ItemValues& ListItemsValuesResponse::values(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsValuesResponse.values)
  return _internal_values(index);
}
inline ::zabmon::ItemValues* ListItemsValuesResponse::_internal_add_values() {
  return values_.Add();
}
inline ::zabmon::ItemValues* ListItemsValuesResponse::add_values() {
  ::zabmon::ItemValues* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:zabmon.ListItemsValuesResponse.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::ItemValues >&
ListItemsValuesResponse::values() const {
  // @@protoc_insertion_point(field_list:zabmon.ListItemsValuesResponse.values)
  return values_;
}

// string next_page_token = 2;
inline void ListItemsValuesResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListItemsValuesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsValuesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListItemsValuesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListItemsValuesResponse.next_page_token)
}
inline std::string* ListItemsValuesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsValuesResponse.next_page_token)
  return _s;
}
inline const std::string& ListItemsValuesResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListItemsValuesResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListItemsValuesResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListItemsValuesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListItemsValuesResponse.next_page_token)
  return next_page_token_.Release();
}
inline void ListItemsValuesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListItemsValuesResponse.next_page_token)
}

// -------------------------------------------------------------------

// ListItemsRequest

// int32 page_size = 4;
inline void ListItemsRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListItemsRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListItemsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsRequest.page_size)
  return _internal_page_size();
}
inline void ListItemsRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListItemsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.page_size)
}

// string page_token = 5;
inline void ListItemsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListItemsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListItemsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.page_token)
}
inline std::string* ListItemsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsRequest.page_token)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListItemsRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListItemsRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListItemsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListItemsRequest.page_token)
  return page_token_.Release();
}
inline void ListItemsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListItemsRequest.page_token)
}

// repeated string groups_ids = 6;
inline int ListItemsRequest::_internal_groups_ids_size() const {
  return groups_ids_.size();
}
inline int ListItemsRequest::groups_ids_size() const {
  return _internal_groups_ids_size();
}
inline void ListItemsRequest::clear_groups_ids() {
  groups_ids_.Clear();
}
inline std::string* ListItemsRequest::add_groups_ids() {
  std::string* _s = _internal_add_groups_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.ListItemsRequest.groups_ids)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_groups_ids(int index) const {
  return groups_ids_.Get(index);
}
inline const std::string& ListItemsRequest::groups_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsRequest.groups_ids)
  return _internal_groups_ids(index);
}
inline std::string* ListItemsRequest::mutable_groups_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsRequest.groups_ids)
  return groups_ids_.Mutable(index);
}
inline void ListItemsRequest::set_groups_ids(int index, const std::string& value) {
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.groups_ids)
}
inline void ListItemsRequest::set_groups_ids(int index, std::string&& value) {
  groups_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.groups_ids)
}
inline void ListItemsRequest::set_groups_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.ListItemsRequest.groups_ids)
}
inline void ListItemsRequest::set_groups_ids(int index, const char* value, size_t size) {
  groups_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.ListItemsRequest.groups_ids)
}
inline std::string* ListItemsRequest::_internal_add_groups_ids() {
  return groups_ids_.Add();
}
inline void ListItemsRequest::add_groups_ids(const std::string& value) {
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.ListItemsRequest.groups_ids)
}
inline void ListItemsRequest::add_groups_ids(std::string&& value) {
  groups_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.ListItemsRequest.groups_ids)
}
inline void ListItemsRequest::add_groups_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.ListItemsRequest.groups_ids)
}
inline void ListItemsRequest::add_groups_ids(const char* value, size_t size) {
  groups_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.ListItemsRequest.groups_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListItemsRequest::groups_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.ListItemsRequest.groups_ids)
  return groups_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListItemsRequest::mutable_groups_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListItemsRequest.groups_ids)
  return &groups_ids_;
}

// repeated string templates_ids = 7;
inline int ListItemsRequest::_internal_templates_ids_size() const {
  return templates_ids_.size();
}
inline int ListItemsRequest::templates_ids_size() const {
  return _internal_templates_ids_size();
}
inline void ListItemsRequest::clear_templates_ids() {
  templates_ids_.Clear();
}
inline std::string* ListItemsRequest::add_templates_ids() {
  std::string* _s = _internal_add_templates_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.ListItemsRequest.templates_ids)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_templates_ids(int index) const {
  return templates_ids_.Get(index);
}
inline const std::string& ListItemsRequest::templates_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsRequest.templates_ids)
  return _internal_templates_ids(index);
}
inline std::string* ListItemsRequest::mutable_templates_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsRequest.templates_ids)
  return templates_ids_.Mutable(index);
}
inline void ListItemsRequest::set_templates_ids(int index, const std::string& value) {
  templates_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.templates_ids)
}
inline void ListItemsRequest::set_templates_ids(int index, std::string&& value) {
  templates_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.templates_ids)
}
inline void ListItemsRequest::set_templates_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  templates_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.ListItemsRequest.templates_ids)
}
inline void ListItemsRequest::set_templates_ids(int index, const char* value, size_t size) {
  templates_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.ListItemsRequest.templates_ids)
}
inline std::string* ListItemsRequest::_internal_add_templates_ids() {
  return templates_ids_.Add();
}
inline void ListItemsRequest::add_templates_ids(const std::string& value) {
  templates_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.ListItemsRequest.templates_ids)
}
inline void ListItemsRequest::add_templates_ids(std::string&& value) {
  templates_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.ListItemsRequest.templates_ids)
}
inline void ListItemsRequest::add_templates_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  templates_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.ListItemsRequest.templates_ids)
}
inline void ListItemsRequest::add_templates_ids(const char* value, size_t size) {
  templates_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.ListItemsRequest.templates_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListItemsRequest::templates_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.ListItemsRequest.templates_ids)
  return templates_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListItemsRequest::mutable_templates_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListItemsRequest.templates_ids)
  return &templates_ids_;
}

// repeated string hosts_ids = 8;
inline int ListItemsRequest::_internal_hosts_ids_size() const {
  return hosts_ids_.size();
}
inline int ListItemsRequest::hosts_ids_size() const {
  return _internal_hosts_ids_size();
}
inline void ListItemsRequest::clear_hosts_ids() {
  hosts_ids_.Clear();
}
inline std::string* ListItemsRequest::add_hosts_ids() {
  std::string* _s = _internal_add_hosts_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.ListItemsRequest.hosts_ids)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_hosts_ids(int index) const {
  return hosts_ids_.Get(index);
}
inline const std::string& ListItemsRequest::hosts_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsRequest.hosts_ids)
  return _internal_hosts_ids(index);
}
inline std::string* ListItemsRequest::mutable_hosts_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsRequest.hosts_ids)
  return hosts_ids_.Mutable(index);
}
inline void ListItemsRequest::set_hosts_ids(int index, const std::string& value) {
  hosts_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.hosts_ids)
}
inline void ListItemsRequest::set_hosts_ids(int index, std::string&& value) {
  hosts_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.ListItemsRequest.hosts_ids)
}
inline void ListItemsRequest::set_hosts_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.ListItemsRequest.hosts_ids)
}
inline void ListItemsRequest::set_hosts_ids(int index, const char* value, size_t size) {
  hosts_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.ListItemsRequest.hosts_ids)
}
inline std::string* ListItemsRequest::_internal_add_hosts_ids() {
  return hosts_ids_.Add();
}
inline void ListItemsRequest::add_hosts_ids(const std::string& value) {
  hosts_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.ListItemsRequest.hosts_ids)
}
inline void ListItemsRequest::add_hosts_ids(std::string&& value) {
  hosts_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.ListItemsRequest.hosts_ids)
}
inline void ListItemsRequest::add_hosts_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.ListItemsRequest.hosts_ids)
}
inline void ListItemsRequest::add_hosts_ids(const char* value, size_t size) {
  hosts_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.ListItemsRequest.hosts_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListItemsRequest::hosts_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.ListItemsRequest.hosts_ids)
  return hosts_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListItemsRequest::mutable_hosts_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListItemsRequest.hosts_ids)
  return &hosts_ids_;
}

// -------------------------------------------------------------------

// ListItemsResponse

// repeated .zabmon.Item items = 1;
inline int ListItemsResponse::_internal_items_size() const {
  return items_.size();
}
inline int ListItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ListItemsResponse::clear_items() {
  items_.Clear();
}
inline ::zabmon::Item* ListItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >*
ListItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListItemsResponse.items)
  return &items_;
}
inline const ::zabmon::Item& ListItemsResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::zabmon::Item& ListItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsResponse.items)
  return _internal_items(index);
}
inline ::zabmon::Item* ListItemsResponse::_internal_add_items() {
  return items_.Add();
}
inline ::zabmon::Item* ListItemsResponse::add_items() {
  ::zabmon::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:zabmon.ListItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Item >&
ListItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:zabmon.ListItemsResponse.items)
  return items_;
}

// string next_page_token = 2;
inline void ListItemsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListItemsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListItemsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListItemsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListItemsResponse.next_page_token)
}
inline std::string* ListItemsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListItemsResponse.next_page_token)
  return _s;
}
inline const std::string& ListItemsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListItemsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListItemsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListItemsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListItemsResponse.next_page_token)
  return next_page_token_.Release();
}
inline void ListItemsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListItemsResponse.next_page_token)
}

// -------------------------------------------------------------------

// ListTemplatesRequest

// int32 page_size = 1;
inline void ListTemplatesRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListTemplatesRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListTemplatesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:zabmon.ListTemplatesRequest.page_size)
  return _internal_page_size();
}
inline void ListTemplatesRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListTemplatesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:zabmon.ListTemplatesRequest.page_size)
}

// string page_token = 2;
inline void ListTemplatesRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListTemplatesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListTemplatesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTemplatesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListTemplatesRequest.page_token)
}
inline std::string* ListTemplatesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListTemplatesRequest.page_token)
  return _s;
}
inline const std::string& ListTemplatesRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListTemplatesRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTemplatesRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTemplatesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListTemplatesRequest.page_token)
  return page_token_.Release();
}
inline void ListTemplatesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListTemplatesRequest.page_token)
}

// repeated string groups_ids = 4;
inline int ListTemplatesRequest::_internal_groups_ids_size() const {
  return groups_ids_.size();
}
inline int ListTemplatesRequest::groups_ids_size() const {
  return _internal_groups_ids_size();
}
inline void ListTemplatesRequest::clear_groups_ids() {
  groups_ids_.Clear();
}
inline std::string* ListTemplatesRequest::add_groups_ids() {
  std::string* _s = _internal_add_groups_ids();
  // @@protoc_insertion_point(field_add_mutable:zabmon.ListTemplatesRequest.groups_ids)
  return _s;
}
inline const std::string& ListTemplatesRequest::_internal_groups_ids(int index) const {
  return groups_ids_.Get(index);
}
inline const std::string& ListTemplatesRequest::groups_ids(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListTemplatesRequest.groups_ids)
  return _internal_groups_ids(index);
}
inline std::string* ListTemplatesRequest::mutable_groups_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListTemplatesRequest.groups_ids)
  return groups_ids_.Mutable(index);
}
inline void ListTemplatesRequest::set_groups_ids(int index, const std::string& value) {
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zabmon.ListTemplatesRequest.groups_ids)
}
inline void ListTemplatesRequest::set_groups_ids(int index, std::string&& value) {
  groups_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zabmon.ListTemplatesRequest.groups_ids)
}
inline void ListTemplatesRequest::set_groups_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zabmon.ListTemplatesRequest.groups_ids)
}
inline void ListTemplatesRequest::set_groups_ids(int index, const char* value, size_t size) {
  groups_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zabmon.ListTemplatesRequest.groups_ids)
}
inline std::string* ListTemplatesRequest::_internal_add_groups_ids() {
  return groups_ids_.Add();
}
inline void ListTemplatesRequest::add_groups_ids(const std::string& value) {
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zabmon.ListTemplatesRequest.groups_ids)
}
inline void ListTemplatesRequest::add_groups_ids(std::string&& value) {
  groups_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zabmon.ListTemplatesRequest.groups_ids)
}
inline void ListTemplatesRequest::add_groups_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zabmon.ListTemplatesRequest.groups_ids)
}
inline void ListTemplatesRequest::add_groups_ids(const char* value, size_t size) {
  groups_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zabmon.ListTemplatesRequest.groups_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListTemplatesRequest::groups_ids() const {
  // @@protoc_insertion_point(field_list:zabmon.ListTemplatesRequest.groups_ids)
  return groups_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListTemplatesRequest::mutable_groups_ids() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListTemplatesRequest.groups_ids)
  return &groups_ids_;
}

// -------------------------------------------------------------------

// ListTemplatesResponse

// repeated .zabmon.Template templates = 1;
inline int ListTemplatesResponse::_internal_templates_size() const {
  return templates_.size();
}
inline int ListTemplatesResponse::templates_size() const {
  return _internal_templates_size();
}
inline void ListTemplatesResponse::clear_templates() {
  templates_.Clear();
}
inline ::zabmon::Template* ListTemplatesResponse::mutable_templates(int index) {
  // @@protoc_insertion_point(field_mutable:zabmon.ListTemplatesResponse.templates)
  return templates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Template >*
ListTemplatesResponse::mutable_templates() {
  // @@protoc_insertion_point(field_mutable_list:zabmon.ListTemplatesResponse.templates)
  return &templates_;
}
inline const ::zabmon::Template& ListTemplatesResponse::_internal_templates(int index) const {
  return templates_.Get(index);
}
inline const ::zabmon::Template& ListTemplatesResponse::templates(int index) const {
  // @@protoc_insertion_point(field_get:zabmon.ListTemplatesResponse.templates)
  return _internal_templates(index);
}
inline ::zabmon::Template* ListTemplatesResponse::_internal_add_templates() {
  return templates_.Add();
}
inline ::zabmon::Template* ListTemplatesResponse::add_templates() {
  ::zabmon::Template* _add = _internal_add_templates();
  // @@protoc_insertion_point(field_add:zabmon.ListTemplatesResponse.templates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zabmon::Template >&
ListTemplatesResponse::templates() const {
  // @@protoc_insertion_point(field_list:zabmon.ListTemplatesResponse.templates)
  return templates_;
}

// string next_page_token = 2;
inline void ListTemplatesResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListTemplatesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:zabmon.ListTemplatesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTemplatesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zabmon.ListTemplatesResponse.next_page_token)
}
inline std::string* ListTemplatesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:zabmon.ListTemplatesResponse.next_page_token)
  return _s;
}
inline const std::string& ListTemplatesResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListTemplatesResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTemplatesResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTemplatesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:zabmon.ListTemplatesResponse.next_page_token)
  return next_page_token_.Release();
}
inline void ListTemplatesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zabmon.ListTemplatesResponse.next_page_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zabmon

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zabmon::ValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zabmon::ValueType>() {
  return ::zabmon::ValueType_descriptor();
}
template <> struct is_proto_enum< ::zabmon::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zabmon::ItemType>() {
  return ::zabmon::ItemType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zabmon_2eproto
